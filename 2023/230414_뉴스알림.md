### [풀이중] - Ref JJH

```cpp
#include <vector>
#include <unordered_map>

using namespace std;

#define OFFERED		0
#define ALARMED		1
#define CANCELED	2

struct User {
	int mUID;
	vector<int> newsList;
	int num_news;
};
struct Channel {
	int mChannelID;
	vector<int> userList;
};
struct News {
	int mNewsID;
	int cIdx;
	int alarmTime;				// mTime + delayTime
	int state;					// OFFERED, ALARMED, CANCELED
};

unordered_map<int, int> userMap;		// 1 <= mUID <= 1,000,000,000
unordered_map<int, int> channelMap;		// 1 <= mChannelID <= 1,000,000,000
unordered_map<int, int> newsMap;		// 1 <= mNewsID <= 1,000,000,000

vector<User> users;
vector<Channel> channels;
vector<News> news;

int userCnt;
int channelCnt;

struct Data {
	int nIdx, alarmTime;

	bool operator<(const Data& data) const { 
		return this->alarmTime > data.alarmTime;
	}
};



////////////////////////////////////////////////////////
int get_userIdx(int mUID) {
	int uIdx;
	auto pos = userMap.find(mUID);
	if (pos == userMap.end()) {
		uIdx = userCnt;
		userMap[mUID] = uIdx;
		userCnt += 1;
	}
	else
		uIdx = pos->second;
	return uIdx;
}
int get_channelIdx(int mChannelID) {
	int cIdx;
	auto pos = channelMap.find(mChannelID);
	if (pos == channelMap.end()) {
		cIdx = channelCnt;
		channelMap[mChannelID] = cIdx;
		channelCnt += 1;
	}
	else
		cIdx = pos->second;
	return cIdx;
}
int get_newsIdx(int mNewsID) {
	int nIdx;
	auto pos = newsMap.find(mNewsID);
	if (pos == newsMap.end()) {
		nIdx = news.size();
		newsMap[mNewsID] = nIdx;
		news.push_back({});
	}
	else
		nIdx = pos->second;
	return nIdx;
}

int update_news(int mTime) {

}

////////////////////////////////////////////////////////
void init(int N, int K)
{
	userMap.clear();
	users.clear();		users.resize(N);		// 0, 1, ..., N-1

	channelMap.clear();
	channels.clear();	channels.resize(K);		// 0, 1, ..., K-1

	newsMap.clear();
	news.clear();

	userCnt = 0;
	channelCnt = 0;
}

// 5,000
// mTime 시각에 유저에게 보내지는 뉴스 알림이 있는 경우 먼저 알림을 보낸 후, mUID 유저를 뉴스 채널에 등록한다.
void registerUser(int mTime, int mUID, int mNum, int mChannelIDs[])
{
	int uIdx = get_userIdx(mUID);
	for (int i = 0; i < mNum; i++) {
		users[uIdx].mUID = mUID;

		int cIdx = get_channelIdx(mChannelIDs[i]);
		channels[cIdx].mChannelID = mChannelIDs[i];
		channels[cIdx].userList.push_back(uIdx);
	}
}

// 30,000
int offerNews(int mTime, int mNewsID, int mDelay, int mChannelID)
{
	int nIdx = get_newsIdx(mNewsID);
	int cIdx = get_channelIdx(mChannelID);

	news[nIdx].mNewsID = mNewsID;
	news[nIdx].cIdx = cIdx;
	news[nIdx].alarmTime = mTime + mDelay;

	for (int uIdx : channels[cIdx].userList) {
		users[uIdx].newsList.push_back(nIdx);
		users[uIdx].num_news += 1;
	}

	return channels[cIdx].userList.size();
}

// 3,000
void cancelNews(int mTime, int mNewsID)
{
	int nIdx = get_newsIdx(mNewsID);
	news[nIdx].state = CANCELED;

	for (int uIdx : channels[news[nIdx].cIdx].userList)
		users[uIdx].num_news -= 1;
}

// 1,000
// mTime 시각에 유저에게 보내지는 뉴스 알림이 있는 경우 먼저 알림을 보낸 후, 유저가 받은 뉴스 알림의 개수를 반환한다.
int checkUser(int mTime, int mUID, int mRetIDs[])
{
	int uIdx = get_userIdx(mUID);

	return users[uIdx].num_news;
}
```
