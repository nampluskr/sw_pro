# 230414_뉴스알림

### `main.cpp`
```c
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <time.h>

extern void init(int N, int K);
extern void registerUser(int mTime, int mUID, int mNum, int mGroupIDs[]);
extern int offerNews(int mTime, int mNewsID, int mDelay, int mGroupID);
extern void cancelNews(int mTime, int mNewsID);
extern int checkUser(int mTime, int mUID, int mRetIDs[]);


/////////////////////////////////////////////////////////////////////////
#define INIT 0
#define REGI 1
#define OFFER 2
#define CANCEL 3
#define CHECK 4

static int gids[30];
static int ansids[3];
static int retids[3];

static bool run()
{

	int N, K;
	int cmd, ans, ret;
	int time, num, uid, gid, nid, delay;
	int Q = 0;
	bool okay = false;

	scanf("%d", &Q);
	for (int q = 0; q < Q; ++q)
	{
		scanf("%d", &cmd);

		switch (cmd)
		{
		case INIT:
			scanf("%d %d", &N, &K);
			init(N, K);
			okay = true;
			break;

		case REGI:
			scanf("%d %d %d", &time, &uid, &num);
			for (int m = 0; m < num; m++) {
				scanf("%d", &gids[m]);
			}

			registerUser(time, uid, num, gids);
			break;

		case OFFER:
			scanf("%d %d %d %d %d", &time, &nid, &delay, &gid, &ans);
			ret = offerNews(time, nid, delay, gid);
			if (ans != ret) {
				okay = false;
			}
			break;

		case CANCEL:
			scanf("%d %d", &time, &nid);
			cancelNews(time, nid);
			break;

		case CHECK:
			scanf("%d %d %d", &time, &uid, &ans);
			ret = checkUser(time, uid, retids);
			num = ans;

			if (num > 3) num = 3;
			for (int m = 0; m < num; m++) {
				scanf("%d", &ansids[m]);
			}

			if (ans != ret) {
				okay = false;
			}
			else {
				for (int m = 0; m < num; m++) {
					if (ansids[m] != retids[m]) {
						okay = false;
					}
				}
			}
			break;

		default:
			okay = false;
		}
	}
	return okay;
}


int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input.txt", "r", stdin);

	int T, MARK;
	scanf("%d %d", &T, &MARK);

	for (int tc = 1; tc <= T; tc++)
	{
		int score = run() ? MARK : 0;
		printf("#%d %d\n", tc, score);
	}
	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf("Result: %d ms\n", result);

	return 0;
}
```

### `solution.cpp` (조지훈)
```c
#include <map>				// Blanced Binary Search Tree : LogN, 메모리는 효율적, 속도는 약간 느림
#include <unordered_map>	// Hash Table : 속도는 빠름 O(1), 메모리는 많이 사용
#include <vector>
#include <queue>			// 우선순위 큐

using namespace std;

struct User
{
	vector<int> news;
};

struct Channel
{
	vector<int> user;
};

struct News
{
	int origin_id;
	int isDeleted;
	int time;
	int channel;
	int id;
};


vector<User> users;
vector<Channel> channel;
vector<News> news;

#define HASH_TABLE	unordered_map<int, int>
//#define HASH_TABLE	map<int, int>

HASH_TABLE userMap;
HASH_TABLE channalMap;
HASH_TABLE newsMap;


struct cmp
{
	bool operator ()(const News& a, const News& b) {
		return a.time > b.time;
	}
};

priority_queue< News, vector<News>, cmp> timeEventQueue;

void notifyNews(int time)
{
	while (timeEventQueue.size() && timeEventQueue.top().time <= time)
	{
		News data = timeEventQueue.top(); timeEventQueue.pop();

		if (news[data.id].isDeleted)
			continue;

		for (auto uid : channel[data.channel].user)
		{
			users[uid].news.push_back(data.id);
		}
	}
}

void init(int N, int K)
{
	userMap.clear();
	channalMap.clear();
	newsMap.clear();

	users.clear();
	channel.clear();
	news.clear();

	while (timeEventQueue.size())
		timeEventQueue.pop();
}

void registerUser(int mTime, int mUID, int mNum, int mChannelIDs[])
{
	// mTime 시각에 유저에게 보내지는 뉴스 알림이 있는 경우 먼저 알림을 보낸 후, mUID 유저를 뉴스 채널에 등록한다.
	notifyNews(mTime);

	// mTime 시각에 mUID 유저는 뉴스 알림을 받기 위해 mNum 개의 뉴스 채널 mChannelIDs[] 에 각각 등록한다.

	int uid;
	auto ret = userMap.find(mUID);

	if (ret == userMap.end()) // 없는 경우 -> 신규 생성
	{
		uid = users.size();
		users.push_back(User());
		userMap[mUID] = uid;
	}
	else {
		uid = ret->second;
	}

	for (int i = 0; i < mNum; i++)
	{
		int cid;
		auto ret = channalMap.find(mChannelIDs[i]);

		if (ret == channalMap.end()) // 없는 경우 -> 신규 생성
		{
			cid = channel.size();

			channel.push_back(Channel());
			channalMap[mChannelIDs[i]] = cid;
		}
		else {
			cid = ret->second;
		}
		channel[cid].user.push_back(uid);
	}
}

int offerNews(int mTime, int mNewsID, int mDelay, int mChannelID)
{
	notifyNews(mTime);

	int cid = channalMap.find(mChannelID)->second;

	int nid = news.size();
	newsMap[mNewsID] = nid;

	news.push_back(News());

	news[nid].channel = cid;
	news[nid].id = nid;
	news[nid].origin_id = mNewsID;
	news[nid].isDeleted = 0;
	news[nid].time = mTime + mDelay;

	timeEventQueue.push(news[nid]);

	return channel[cid].user.size();
}



void cancelNews(int mTime, int mNewsID)
{
	int nid = newsMap.find(mNewsID)->second;
	news[nid].isDeleted = 1;
}

struct cmp2
{
	bool operator ()(const News& a, const News& b) {
		return (a.time < b.time) || (a.time == b.time && a.origin_id < b.origin_id);
	}
};

int checkUser(int mTime, int mUID, int mRetIDs[])
{
	// mTime 시각에 유저에게 보내지는 뉴스 알림이 있는 경우 먼저 알림을 보낸 후, 유저가 받은 뉴스 알림의 개수를 반환한다.
	notifyNews(mTime);

	int ret = 0;

	int uid = userMap.find(mUID)->second;

#if 0

	News data[5];
	for (int i = 0; i < 5; i++)
		data[i].time = -1;

	for (auto n : users[uid].news)
	{
		if (news[n].isDeleted == 1)
			continue;

		for (int i = 0; i < 3; i++)
		{
			// return (a.time < b.time) || (a.time == b.time && a.origin_id < b.origin_id);
			if ((data[i].time < news[n].time) || (data[i].time == news[n].time && data[i].origin_id < news[n].origin_id)) {
				/* 1 [2] 3 5  */
				for (int j = 3; j >= i; j--)
				{
					data[j + 1] = data[j];
				}

				data[i] = news[n];
				break;
			}
		}

		ret++;
	}

	for (int i = 0; i < min(3, ret); i++)
	{
		mRetIDs[i] = data[i].origin_id;
	}

#else
	priority_queue<News, vector<News>, cmp2> Q;

	for (auto n : users[uid].news)
	{
		if (news[n].isDeleted == 1)
			continue;

		ret++;
		Q.push(news[n]);
	}

	int idx = 0;
	while (Q.size() and idx < 3)
	{
		mRetIDs[idx] = Q.top().origin_id;
		Q.pop();
		idx++;
	}
#endif

	//함수 호출 후, mUID 유저가 받은 뉴스 알림은 모두 삭제되어 알림의 개수는 0 이 된다.
	users[uid].news.clear();

	return ret;
}
```

### `sample_input.txt`
```
25 100
32
0 3 5
1 1 11 2 111 222
1 2 22 3 333 444 555
1 3 33 2 555 111
2 5 12345 20 555 2
2 10 54321 15 111 2
2 11 11111 14 222 1
2 14 22222 20 444 1
2 17 33333 8 333 1
4 20 33 0
1 25 11 3 444 333 555
4 26 11 2 54321 11111
4 27 33 2 54321 12345
2 28 32112 8 333 2
2 29 56789 9 444 2
2 30 12215 5 555 3 
3 32 22222
2 34 34219 18 111 2
3 35 12215
4 36 22 3 32112 33333 12345
4 37 22 0
3 40 56789
4 41 11 1 32112
2 47 55555 10 222 1
2 48 77777 13 222 1
2 49 77111 10 555 3
2 51 34577 10 111 2
2 57 88888 4 444 2
2 59 99999 10 111 2
4 61 11 6 88888 77777 34577
4 62 22 2 88888 77111
4 63 33 3 34577 77111 34219
31
0 3 5
1 1 11 2 111 222
1 2 22 3 333 444 555
1 3 33 2 555 111
2 5 12345 20 555 2
2 10 54321 15 111 2
2 11 11111 14 222 1
2 14 22222 20 444 1
2 17 33333 8 333 1
4 20 33 0
1 25 11 3 444 333 555
4 26 11 2 54321 11111
4 27 33 2 54321 12345
2 28 32112 8 333 2
2 29 56789 9 444 2
2 30 12215 5 555 3 
3 32 22222
2 34 34219 18 111 2
3 35 12215
4 36 22 3 32112 33333 12345
3 40 56789
4 41 11 1 32112
2 47 55555 10 222 1
2 48 77777 13 222 1
2 49 77111 10 555 3
2 51 34577 10 111 2
2 57 88888 4 444 2
2 59 99999 10 111 2
4 61 11 6 88888 77777 34577
4 62 22 2 88888 77111
4 63 33 3 34577 77111 34219
100
0 20 20
1 3 30006 2 27067 11039
2 6 9974 258 27067 1
2 15 2704 552 27067 1
2 19 17526 486 11039 1
2 28 4942 804 27067 1
2 35 14390 604 27067 1
2 37 29562 700 27067 1
2 38 16832 224 27067 1
1 40 1659 2 30063 19080
2 48 13244 997 19080 1
2 58 3977 684 27067 1
2 67 29898 88 11039 1
2 73 23054 983 19080 1
1 76 12205 1 27067
2 78 17608 565 19080 1
2 80 3691 849 11039 1
2 82 18005 664 19080 1
2 83 11955 573 27067 2
1 87 18258 3 5604 27336 27067
2 96 5418 620 19080 1
1 104 31125 1 4135
2 108 14138 888 30063 1
2 110 9812 291 5604 1
2 115 29224 311 5604 1
2 118 6288 804 30063 1
3 123 14390
2 130 24095 252 30063 1
1 134 30006 3 9205 5604 27336
3 141 2704
2 149 28111 376 5604 2
2 157 221 751 9205 1
2 162 31897 889 5604 2
2 166 29683 622 5604 2
2 170 12146 330 19080 1
2 171 28420 257 30063 1
2 174 16051 106 11039 1
2 181 23540 588 4135 1
2 186 430 50 5604 2
1 192 710 1 11039
2 202 1988 652 19080 1
2 203 18588 98 9205 1
2 211 31731 850 27067 3
2 215 10007 157 19080 1
2 222 10290 661 11039 2
2 229 2442 885 27336 2
2 230 26863 613 9205 1
2 234 3770 555 27336 2
2 242 5806 633 4135 1
2 249 24123 6 9205 1
2 254 15732 433 11039 2
2 257 20544 106 27336 2
2 263 19580 253 11039 2
2 264 26422 87 9205 1
2 267 29490 224 27067 3
2 273 17251 124 30063 1
2 277 7549 34 19080 1
2 280 18670 849 30063 1
2 282 13474 989 19080 1
2 284 26271 838 5604 2
1 288 24273 3 14041 4135 11039
2 295 32597 866 14041 1
2 300 26737 980 14041 1
2 301 14205 109 5604 2
2 305 21 603 27067 3
1 315 24647 1 9205
2 316 26679 723 5604 2
2 324 12062 316 30063 1
2 327 1095 202 4135 2
2 334 22326 819 9205 2
2 339 17470 10 14041 1
2 347 12705 853 27067 3
1 349 18258 2 9059 3856
2 352 23523 173 9205 2
2 356 23166 9 5604 2
2 366 31033 209 27067 3
2 369 26479 641 14041 1
2 378 14494 96 30063 1
2 384 27990 188 19080 1
3 387 12705
2 396 22881 67 11039 3
2 401 21918 257 30063 1
2 407 29483 325 30063 1
2 412 6667 454 11039 3
2 414 21921 652 27336 2
4 421 18258 7 14205 9812 23166
1 424 12205 3 14041 3856 4135
2 432 8063 52 9205 2
2 435 23183 966 4135 3
2 445 23980 496 27336 2
2 451 31722 411 9059 1
2 461 7850 268 3856 2
2 469 10343 292 11039 3
2 478 24872 783 4135 3
2 479 16940 801 11039 3
1 481 1659 3 5604 3856 15733
2 488 17342 963 30063 1
1 497 10189 3 5604 15351 17275
2 503 1233 940 5604 4
2 512 21768 531 11039 3
```
