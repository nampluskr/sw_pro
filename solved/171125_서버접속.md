## 171125_서버접속

### [soltuoin-1] 완전 탐색 / 기능 구현 1081 ms

### [solution-2] getUserIdx() 개선 필요 => 50000 x 10000 x 2 = 10억: Logout(), Connect()
- => 문자열 key: 해시 테이블 + 해시 체이닝 사용 752 ms
- *** 해시 테이블 3가지 경우 ***
- (1) 1~50000만 정수 key => 배열 인덱스로 사용
- (2) 1~10억    정수 key => 해시 함수 사용 (배열 > 256M 이상됨)
- (3) 문자열 key => 해시 함수 사용
 
### [solution-3] tick() 개선 필요: 50000 x 50000 = 25억
- => 특정 시각에 logout 되는 user 만 확인: 반드시 링크드 리스트 사용 30 ms
- loginTime -> logoutTime (=currentTime + defaulttime) 변경
- 링크드 리스트에 추가만 하고 삭제는 하지 않음

### `solution.cpp`
```c
// 사용자 계정의 login / logout 을 관리하는 서버 기능 구현한다.
// 보안을 위해 각각의 계정 별로 접속시간이 정해져 있다.
// 사용자가 서버에 login success 후, 접속시간이 0이 되면 자동으로 logout 된다.

// 각 테스트 케이스의 맨 처음에 초기화의 목적으로 호출된다.
void Init() {}

// 새로운 사용자 계정을 추가 한다.
// 해당 계정은 자동으로 login 되면, 접속시간은 defaulttime 으로 초기화 된다.
// 1 <= defaulttime <= 30000, 최대 50,000번 호출
void NewAccount(char id[11], char password[11], int defaulttime) {}

// id에 해당하는 계정의 서버 접속을 종료한다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
void Logout(char id[11]) {}

// 서버에 login 되어 있는 계정 중, id/password 가 일치하는 계정의 접속시간이 defaulttime 값으로 초기화 된다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
void Connect(char id[11], char password[11]) {}

// login 되어 있는 모든 계정의 접속시간이 1 감소되며, 접속시간이 0이 되는 계정은 자동으로 logout 된다.
// 접속시간이 0이 되어 자동으로 logout 되는 계정의 수를 리턴한다.
// 최대 50,000번 호출
int Tick() { return 0; }
```

### `main.cpp`
```c
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <string.h>
#include <time.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

extern void Init();
extern void NewAccount(char id[11], char password[11], int defaulttime);
extern void Logout(char id[11]);
extern void Connect(char id[11], char password[11]);
extern int Tick();

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define MAX_ACCOUNT 50000
#define MAX_TIME 30000

typedef enum {
	INIT,
	NEWACCOUNT,
	LOGOUT,
	CONNECT,
	TICK
}STATE;

typedef struct {
	char id[11];
	char password[11];
	int defaulttime;
}ACCOUNT;
static ACCOUNT account[MAX_ACCOUNT];

static int mSeed;
static int mrand(int num)
{
	mSeed = mSeed * 1103515245 + 12345;
	return (((mSeed >> 16) & 0x7FFF) % num);
}

static void make_account(int cnt)
{
	for (int i = 0; i < cnt; i++) {
		int idl = 5 + mrand(6);
		for (int k = 0; k < idl; k++) {
			int ch = mrand(36);
			if (ch < 10) account[i].id[k] = ch + '0';
			else account[i].id[k] = ch - 10 + 'a';
		}
		account[i].id[idl] = '\0';

		int pal = 5 + mrand(6);
		for (int k = 0; k < pal; k++) {
			int ch = mrand(36);
			if (ch < 10) account[i].password[k] = ch + '0';
			else account[i].password[k] = ch - 10 + 'a';
		}
		account[i].password[pal] = '\0';

		int max_time = cnt;
		if (max_time > MAX_TIME) max_time = MAX_TIME;
		account[i].defaulttime = 1 + mrand(max_time);
	}
}

static void init(int num)
{
	Init();

	make_account(num);
	for (int i = 0; i < num / 3; i++) {
		char id[11], password[11];
		int defaulttime;
		strcpy(id, account[i].id);
		strcpy(password, account[i].password);
		defaulttime = account[i].defaulttime;
		NewAccount(id, password, defaulttime);
	}
}

static int run()
{
	int ret = 1;
	int cmd, param1, param2, num, cmdcnt;

	char id[11], password[11];
	int defaulttime;

	scanf("%d %d %d %d", &cmd, &mSeed, &num, &cmdcnt);
	init(num);

	for (int i = 0; i < cmdcnt; i++) {
		scanf("%d", &cmd);
		if (cmd == NEWACCOUNT) {
			scanf("%d %d", &param1, &param2);
			strcpy(id, account[param1].id);
			strcpy(password, account[param1].password);
			defaulttime = param2;
			NewAccount(id, password, defaulttime);
		}
		else if (cmd == LOGOUT) {
			scanf("%d", &param1);
			strcpy(id, account[param1].id);
			Logout(id);
		}
		else if (cmd == CONNECT) {
			scanf("%d %d", &param1, &param2);
			strcpy(id, account[param1].id);
			strcpy(password, account[param2].password);
			Connect(id, password);
		}
		else if (cmd == TICK) {
			scanf("%d", &param1);
			int result = Tick();
			if (result != param1)
				ret = 0;
		}
	}

	return ret;
}

int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input.txt", "r", stdin);

	int T;
	scanf("%d", &T);

	for (int tc = 1; tc <= T; tc++)
	{
		int Score = 100;
		if (run() == 0)
			Score = 0;

		printf("#%d %d\n", tc, Score);
	}

	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf(">> Result: %d ms\n", result);
	return 0;
}
```

### [soltuoin-1] 완전 탐색 / 기능 구현 1081 ms

```c
#define MAX_USER 50'000
#define MAX_TIME 50'000
#define MAX_TABLE 50'007

void mstrcpy(char dst[], const char src[]) {
	int c = 0;
	while ((dst[c] = src[c]) != 0) ++c;
}

int mstrcmp(const char str1[], const char str2[]) {
	int c = 0;
	while (str1[c] != 0 && str1[c] == str2[c]) ++c;
	return str1[c] - str2[c];
}

struct User {
	char id[11];			// 입력값
	char password[11];		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};

User user[MAX_USER];
int userCount;


int getUserIdx(char id[11])
{
	for (int i = 0; i < userCount; i++) {
		if (mstrcmp(user[i].id, id) == 0) {
			return i;
		}
	}
	return -1;
}

/////////////////////////////////////////////////////////////

// 각 테스트 케이스의 맨 처음에 초기화의 목적으로 호출된다.
void Init()
{
	userCount = 0;
}

// 새로운 사용자 계정을 추가 한다.
// 해당 계정은 자동으로 login 되면, 접속시간은 defaulttime 으로 초기화 된다.
// 1 <= defaulttime <= 30000, 최대 50,000번 호출
void NewAccount(char id[11], char password[11], int defaulttime)
{
	mstrcpy(user[userCount].id, id);
	mstrcpy(user[userCount].password, password);
	user[userCount].defaulttime = defaulttime;

	user[userCount].loginTime = defaulttime;
	user[userCount].isLogout = false;

	userCount++;
}

// id에 해당하는 계정의 서버 접속을 종료한다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
void Logout(char id[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	user[uIdx].isLogout = true;
}

// 서버에 login 되어 있는 계정 중, id/password 가 일치하는 계정의 접속시간이 defaulttime 값으로 초기화 된다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
void Connect(char id[11], char password[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	if (mstrcmp(user[uIdx].password, password) != 0)
		return;

	user[uIdx].loginTime = user[uIdx].defaulttime;
}

// login 되어 있는 모든 계정의 접속시간이 1 감소되며, 접속시간이 0이 되는 계정은 자동으로 logout 된다.
// 접속시간이 0이 되어 자동으로 logout 되는 계정의 수를 리턴한다.
// 최대 50,000번 호출
int Tick()
{
	int logoutUserCount = 0;

	for (int i = 0; i < userCount; i++) {
		if (user[i].isLogout)
			continue;

		user[i].loginTime -= 1;

		if (user[i].loginTime == 0) {
			user[i].isLogout = true;
			logoutUserCount++;
		}
	}

	return logoutUserCount;
}
```

### [solution-2] getUserIdx() 개선 필요 => 50000 x 10000 x 2 = 10억: Logout(), Connect()

```c
#define MAX_USER 50'000
#define MAX_TIME 50'000
#define MAX_TABLE 50'007		// 해시 value 의 개수

// 링크드 리스트 => 해시 체이닝
struct ListNode {
	int id;				// user 배열의 인덱스 정보
	ListNode* next;
};

ListNode heap[1000000];		// 메모리 최대한 사용 (정적 선언)
int hrp;

// head 앞에 새로운 노드 추가
// 새로운 노드를 만들고 그 새로운 노드가 기존 head 를 가리키게 하고,
// 새로 만들어진 노드의 주소를 리턴한다.
ListNode* appendListNode(int id, ListNode* oldHead) {
	// ListNode* node = new ListNode;		// 동적 할당이므로 할당 해제 필요
	ListNode* node = &heap[hrp++];			// 정적 메모리 사용

	node->id = id;
	node->next = oldHead;

	return node;
}

ListNode* head[MAX_TABLE];	// Hash Chaining

unsigned long hash(const char* str) 
{
	unsigned long hash = 5381;
	int c;

	while (c = *str++) {
		hash = (((hash << 5) + hash) + c) % MAX_TABLE;
	}
	return hash % MAX_TABLE;
}

void mstrcpy(char dst[], const char src[]) {
	int c = 0;
	while ((dst[c] = src[c]) != 0) ++c;
}

int mstrcmp(const char str1[], const char str2[]) {
	int c = 0;
	while (str1[c] != 0 && str1[c] == str2[c]) ++c;
	return str1[c] - str2[c];
}

struct User {
	char id[11];			// 입력값
	char password[11];		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};

User user[MAX_USER];
int userCount;


int getUserIdx(char id[11])
{
	//for (int i = 0; i < userCount; i++) {
	//	if (mstrcmp(user[i].id, id) == 0) {
	//		return i;
	//	}
	//}

	int hashkey = hash(id);

	ListNode* temp = head[hashkey];
	while (temp != 0) {
		int i = temp->id;
		if (mstrcmp(user[i].id, id) == 0) {
			return i;
		}
		temp = temp->next;
	}

	return -1;
}

/////////////////////////////////////////////////////////////

// 각 테스트 케이스의 맨 처음에 초기화의 목적으로 호출된다.
void Init()
{
	userCount = 0;
	hrp = 0;			// 정적 메모리 heap 초기화 (new, delete 미사용으로 속도 향상)

	// Hash chaining 초기화
	for (int i = 0; i < MAX_TABLE; i++) {
		head[i] = 0;
	}
}

// 새로운 사용자 계정을 추가 한다.
// 해당 계정은 자동으로 login 되면, 접속시간은 defaulttime 으로 초기화 된다.
// 1 <= defaulttime <= 30000, 최대 50,000번 호출
void NewAccount(char id[11], char password[11], int defaulttime)
{
	mstrcpy(user[userCount].id, id);
	mstrcpy(user[userCount].password, password);
	user[userCount].defaulttime = defaulttime;

	user[userCount].loginTime = defaulttime;
	user[userCount].isLogout = false;

	int hashkey = hash(id);
	head[hashkey] = appendListNode(userCount, head[hashkey]);

	userCount++;
}

// id에 해당하는 계정의 서버 접속을 종료한다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
// 호출 회수: 5000~10000번 가정
void Logout(char id[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	user[uIdx].isLogout = true;
}

// 서버에 login 되어 있는 계정 중, id/password 가 일치하는 계정의 접속시간이 defaulttime 값으로 초기화 된다.
// 서버에 login 되어 있지 않는 계정은 아무런 동작도 하지 않는다.
// 호출 회수: 5000~10000번 가정
void Connect(char id[11], char password[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	if (mstrcmp(user[uIdx].password, password) != 0)
		return;

	user[uIdx].loginTime = user[uIdx].defaulttime;
}

// login 되어 있는 모든 계정의 접속시간이 1 감소되며, 접속시간이 0이 되는 계정은 자동으로 logout 된다.
// 접속시간이 0이 되어 자동으로 logout 되는 계정의 수를 리턴한다.
// 최대 50,000번 호출
int Tick()
{
	int logoutUserCount = 0;

	for (int i = 0; i < userCount; i++) {
		if (user[i].isLogout)
			continue;

		user[i].loginTime -= 1;

		if (user[i].loginTime == 0) {
			user[i].isLogout = true;
			logoutUserCount++;
		}
	}

	return logoutUserCount;
}
```

### [solution-3] tick() 개선 필요: 50000 x 50000 = 25억
=> 특정 시각에 logout 되는 user 만 확인: 반드시 링크드 리스트 사용 30 ms

```c
#define MAX_USER 50'000
#define MAX_TIME 100'000		// 50000 (user) + 30000 (time) => 넉넉하게 지정
#define MAX_TABLE 50'007		// 해시 value 의 개수

// [문자열 key 값에 해당하는 user id's] 링크드 리스트 => 해시 체이닝
struct ListNode {
	int id;				// user 배열의 인덱스 정보
	ListNode* next;
};

ListNode heap[1000000];		// 메모리 최대한 사용 (정적 선언)
int hrp;

// head 앞에 새로운 노드 추가
// 새로운 노드를 만들고 그 새로운 노드가 기존 head 를 가리키게 하고,
// 새로 만들어진 노드의 주소를 리턴한다.
ListNode* appendListNode(int id, ListNode* oldHead) {
	// ListNode* node = new ListNode;		// 동적 할당이므로 할당 해제 필요
	ListNode* node = &heap[hrp++];			// 정적 메모리 사용

	node->id = id;
	node->next = oldHead;

	return node;
}

ListNode* head[MAX_TABLE];	// Hash Chaining

// [특정시간에 logout 되는 유저 id's] 링크드 리스트
ListNode* logoutUser[MAX_TIME];


unsigned long hash(const char* str)
{
	unsigned long hash = 5381;
	int c;

	while (c = *str++) {
		hash = (((hash << 5) + hash) + c) % MAX_TABLE;
	}
	return hash % MAX_TABLE;
}

void mstrcpy(char dst[], const char src[]) {
	int c = 0;
	while ((dst[c] = src[c]) != 0) ++c;
}

int mstrcmp(const char str1[], const char str2[]) {
	int c = 0;
	while (str1[c] != 0 && str1[c] == str2[c]) ++c;
	return str1[c] - str2[c];
}

struct User {
	char id[11];			// 입력값
	char password[11];		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	//int loginTime;			// 로그인 상태를 유지할 수 있는 시간
	int logoutTime;				// 예상 로그아웃 시간 = currentTime + defaulttime
};

User user[MAX_USER];
int userCount;
int currentTime;

int getUserIdx(char id[11])
{
	//for (int i = 0; i < userCount; i++) {
	//	if (mstrcmp(user[i].id, id) == 0) {
	//		return i;
	//	}
	//}

	int hashkey = hash(id);

	ListNode* temp = head[hashkey];
	while (temp != 0) {
		int i = temp->id;
		if (mstrcmp(user[i].id, id) == 0) {
			return i;
		}
		temp = temp->next;
	}

	return -1;
}

/////////////////////////////////////////////////////////////
void Init()
{
	userCount = 0;
	currentTime = 0;
	hrp = 0;			// 정적 메모리 heap 초기화 (new, delete 미사용으로 속도 향상)

	// Hash chaining 초기화
	for (int i = 0; i < MAX_TABLE; i++) {
		head[i] = 0;
	}

	for (int i = 0; i < MAX_TIME; i++) {
		logoutUser[i] = 0;
	}
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	mstrcpy(user[userCount].id, id);
	mstrcpy(user[userCount].password, password);
	user[userCount].defaulttime = defaulttime;

	//user[userCount].loginTime = defaulttime;
	user[userCount].logoutTime = currentTime + defaulttime;
	user[userCount].isLogout = false;

	int hashkey = hash(id);
	head[hashkey] = appendListNode(userCount, head[hashkey]);

	// logout 시간에 logout 되는 유저 id 추가
	logoutUser[user[userCount].logoutTime] = appendListNode(userCount, logoutUser[user[userCount].logoutTime]);

	userCount++;
}

void Logout(char id[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	user[uIdx].isLogout = true;
}

void Connect(char id[11], char password[11])
{
	int uIdx = getUserIdx(id);

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	if (mstrcmp(user[uIdx].password, password) != 0)
		return;

	//user[uIdx].loginTime = user[uIdx].defaulttime;
	user[uIdx].logoutTime = currentTime + user[uIdx].defaulttime;

	// logout 시간에 logout 되는 유저 id 추가
	logoutUser[user[uIdx].logoutTime] = appendListNode(uIdx, logoutUser[user[uIdx].logoutTime]);
}

int Tick()
{
	int logoutUserCount = 0;
	currentTime += 1;

	ListNode* temp = logoutUser[currentTime];
	while (temp != 0) {
		int i = temp->id;

		if (user[i].isLogout) {
			temp = temp->next;
			continue;
		}

		if (user[i].logoutTime == currentTime) {
			user[i].isLogout = true;
			logoutUserCount++;
		}
		temp = temp->next;
	}

	//for (int i = 0; i < userCount; i++) {
	//	if (user[i].isLogout)
	//		continue;

	//	//user[i].loginTime -= 1;

	//	//if (user[i].loginTime == 0) {
	//	if (user[i].logoutTime == currentTime) {
	//		user[i].isLogout = true;
	//		logoutUserCount++;
	//	}
	//}

	return logoutUserCount;
}
```
