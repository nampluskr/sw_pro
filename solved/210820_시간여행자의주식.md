## 210820_시간여행자의주식

### [main.cpp]

```cpp
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <time.h>

#define CMD_INIT 1
#define CMD_BUY 2
#define CMD_SELL 3
#define CMD_CANCEL 4
#define CMD_BEST_PROFIT 5

extern void init();
extern int buy(int mNumber, int mStock, int mQuantity, int mPrice);
extern int sell(int mNumber, int mStock, int mQuantity, int mPrice);
extern void cancel(int mNumber);
extern int bestProfit(int mStock);

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

static bool run()
{
    int numQuery;
    int mNumber, mStock, mQuantity, mPrice;
    int userAns, ans;
    bool isCorrect = false;

    scanf("%d", &numQuery);
    for (int i = 0; i < numQuery; ++i)
    {
        int cmd;
        scanf("%d", &cmd);
        switch (cmd)
        {
        case CMD_INIT:
            init();
            isCorrect = true;
            break;
        case CMD_BUY:
            scanf("%d %d %d %d", &mNumber, &mStock, &mQuantity, &mPrice);
            userAns = buy(mNumber, mStock, mQuantity, mPrice);
            scanf("%d", &ans);
            if (userAns != ans)
            {
                isCorrect = false;
            }
            break;
        case CMD_SELL:
            scanf("%d %d %d %d", &mNumber, &mStock, &mQuantity, &mPrice);
            userAns = sell(mNumber, mStock, mQuantity, mPrice);
            scanf("%d", &ans);
            if (userAns != ans)
            {
                isCorrect = false;
            }
            break;
        case CMD_CANCEL:
            scanf("%d", &mNumber);
            cancel(mNumber);
            break;
        case CMD_BEST_PROFIT:
            scanf("%d", &mStock);
            userAns = bestProfit(mStock);
            scanf("%d", &ans);
            if (userAns != ans)
            {
                isCorrect = false;
            }
            break;
        default:
            isCorrect = false;
            break;
        }
    }
    return isCorrect;
}

int main()
{
    clock_t start = clock();

    setbuf(stdout, NULL);
    freopen("sample_input.txt", "r", stdin);

    int T, MARK;
    scanf("%d %d", &T, &MARK);

    for (int tc = 1; tc <= T; tc++)
    {
        int score = run() ? MARK : 0;
        printf("#%d %d\n", tc, score);
    }

    int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
    printf(">> Result = %d ms\n", result);
    return 0;
}
```

### [solution.cpp] Template

```cpp
void init() {}

// 매수 주문정보 저장    
// 거래 체결
// - 최저가격 매도주문 탐색
// - 현 매수주문과 체결 가능한지 체크        
// - 최저번호 매도주문 탐색
// - 체결 
// 체결 후 주문 수량 반환 
int buy(int mNumber, int mStock, int mQuantity, int mPrice) { return 0; }

// 매도 주문정보 저장
// 거래 체결  
// - 최고가격 매수주문 탐색
// - 현 매도주문과 체결 가능한지 체크        
// - 최저번호 매수주문 탐색
// - 체결   
// 체결 후 주문 수량 반환
int sell(int mNumber, int mStock, int mQuantity, int mPrice) { return 0; }

void cancel(int mNumber) {}

int bestProfit(int mStock) { return 0; }
```

### [조수장] 완전탐색

```cpp
#define MAX_ORDER   200001
#define MAX_STOCK         6
#define TYPE_BUY      true
#define TYPE_SELL     false
#define INVALID_ORDER    0

struct Order {
	int stock;
	int quantity;
	int price;
	bool type;
};

Order orders[MAX_ORDER];
int minPrice[MAX_STOCK];
int maxProfit[MAX_STOCK];

////////////////////////////////////////////////////////
void init()
{
	for (int i = 1; i < MAX_STOCK; i++) {
		minPrice[i] = 1000000;
		maxProfit[i] = 0;
	}
	for (int oIdx = 1; oIdx < MAX_ORDER; oIdx++) {
		orders[oIdx].quantity = INVALID_ORDER;
	}
}

int findBuyOrder(int mStock, int mPrice)
{
	int max = 0;
	int ret = -1;

	for (int oIdx = 1; oIdx < MAX_ORDER; oIdx++) {
		Order o = orders[oIdx];

		if (o.type == TYPE_SELL)
			continue;

		if (o.stock != mStock)
			continue;

		if (o.quantity == INVALID_ORDER)
			continue;

		if (o.price < mPrice)
			continue;

		if (o.price > max) {
			max = o.price;
			ret = oIdx;
		}
	}
	return ret;
}

int findSellOrder(int mStock, int mPrice)
{
	int min = 9999999;
	int ret = -1;

	for (int oIdx = 1; oIdx < MAX_ORDER; oIdx++) {
		Order o = orders[oIdx];

		if (o.type == TYPE_BUY)
			continue;

		if (o.stock != mStock)
			continue;

		if (o.quantity == INVALID_ORDER)
			continue;

		if (o.price > mPrice)
			continue;

		if (o.price < min) {
			min = o.price;
			ret = oIdx;
		}
	}
	return ret;
}

void conclude(int mBID, int mSID, bool mType)
{
	Order buy = orders[mBID];
	Order sell = orders[mSID];

	if (buy.quantity < sell.quantity) {
		sell.quantity = sell.quantity - buy.quantity;
		buy.quantity = INVALID_ORDER;
	}
	else if (buy.quantity == sell.quantity) {
		buy.quantity = INVALID_ORDER;
		sell.quantity = INVALID_ORDER;
	}
	else {
		buy.quantity = buy.quantity - sell.quantity;
		sell.quantity = INVALID_ORDER;
	}

	int price = -1;
	int stock = buy.stock;

	if (mType == TYPE_BUY) {
		price = sell.price;
	}
	else {
		price = buy.price;
	}

	if (price < minPrice[stock]) {
		minPrice[stock] = price;
	}

	if (price - minPrice[stock] > maxProfit[stock]) {
		maxProfit[stock] = price - minPrice[stock];
	}

	orders[mBID] = buy;
	orders[mSID] = sell;
}

int buy(int mNumber, int mStock, int mQuantity, int mPrice)
{
	int bIdx = mNumber;
	orders[bIdx] = { mStock, mQuantity, mPrice, TYPE_BUY };

	while (1) {
		if (orders[bIdx].quantity == INVALID_ORDER)
			break;

		int sIdx = findSellOrder(mStock, mPrice);

		if (sIdx == -1)
			break;

		conclude(bIdx, sIdx, TYPE_BUY);
	}
	return orders[bIdx].quantity;
}

int sell(int mNumber, int mStock, int mQuantity, int mPrice) {
	int sIdx = mNumber;
	orders[sIdx] = { mStock, mQuantity, mPrice, TYPE_SELL };

	while (1) {
		if (orders[sIdx].quantity == INVALID_ORDER)
			break;

		int bIdx = findBuyOrder(mStock, mPrice);
		if (bIdx == -1)
			break;

		conclude(bIdx, sIdx, TYPE_SELL);
	}
	return orders[sIdx].quantity;
}

void cancel(int mNumber)
{
	orders[mNumber].quantity = INVALID_ORDER;
}

int bestProfit(int mStock)
{
	return maxProfit[mStock];
}
```

### [조수장] 우선순위 큐

```cpp
#include < queue >

using namespace std;

#define MAX_ORDER       200001
#define MAX_STOCK       6
#define TYPE_BUY        true
#define TYPE_SELL       false
#define INVALID_ORDER   0

struct Order {
	int stock;
	int quantity;
	int price;
	bool type;
};

struct Data {
	int value;
	int index;
};

struct buyComparator {
	bool operator()(const Data& o1, const Data& o2)
	{
		if (o2.value > o1.value)
			return true;
		else if (o2.value < o1.value)
			return false;
		else
		{
			if (o2.index < o1.index)
				return true;
			else
				return false;
		}
	}
};

struct sellComparator {
	bool operator()(const Data& o1, const Data& o2)
	{
		if (o2.value < o1.value)
			return true;
		else if (o2.value > o1.value)
			return false;
		else
		{
			if (o2.index < o1.index)
				return true;
			else
				return false;
		}
	}
};

Order orders[MAX_ORDER];
int minPrice[MAX_STOCK];
int maxProfit[MAX_STOCK];

priority_queue <Data, vector<Data>, buyComparator> buyQueue[MAX_STOCK];
priority_queue <Data, vector<Data>, sellComparator> sellQueue[MAX_STOCK];


////////////////////////////////////////////////////////////////////////
void init()
{
	for (int i = 1; i < MAX_STOCK; i++) {
		minPrice[i] = 1000000;
		maxProfit[i] = 0;

		while (buyQueue[i].empty() == false)
			buyQueue[i].pop();
		while (sellQueue[i].empty() == false)
			sellQueue[i].pop();
	}
	for (int oIdx = 1; oIdx < MAX_ORDER; oIdx++) {
		orders[oIdx].quantity = INVALID_ORDER;
	}
}


int findBuyOrder(int mStock, int mPrice)
{
	int stock = mStock;
	int price = mPrice;

	while (buyQueue[stock].empty() == false) {
		Data d = buyQueue[stock].top();
		buyQueue[stock].pop();
		int bIdx = d.index;

		if (orders[bIdx].quantity == INVALID_ORDER)
			continue;

		if (d.value >= price)
			return bIdx;

		buyQueue[stock].push(d);
		break;
	}
	return -1;
}


int findSellOrder(int mStock, int mPrice)
{
	int stock = mStock;
	int price = mPrice;

	while (sellQueue[stock].empty() == false) {
		Data d = sellQueue[stock].top();
		sellQueue[stock].pop();
		int sIdx = d.index;

		if (orders[sIdx].quantity == INVALID_ORDER)
			continue;

		if (d.value <= price)
			return sIdx;

		sellQueue[stock].push(d);
		break;
	}
	return -1;
}


void conclude(int mBID, int mSID, bool mType)
{
	Order buy = orders[mBID];
	Order sell = orders[mSID];

	if (buy.quantity < sell.quantity) {
		sell.quantity = sell.quantity - buy.quantity;
		buy.quantity = 0;
	}
	else if (buy.quantity == sell.quantity) {
		buy.quantity = 0;
		sell.quantity = 0;
	}
	else {
		buy.quantity = buy.quantity - sell.quantity;
		sell.quantity = 0;
	}

	int price = -1;
	int stock = buy.stock;

	if (mType == TYPE_BUY) {
		price = sell.price;
	}
	else {
		price = buy.price;
	}

	if (price < minPrice[stock]) {
		minPrice[stock] = price;
	}

	if (price - minPrice[stock] > maxProfit[stock]) {
		maxProfit[stock] = price - minPrice[stock];
	}

	orders[mBID] = buy;
	orders[mSID] = sell;
}


int buy(int mNumber, int mStock, int mQuantity, int mPrice) {
	int bIdx = mNumber;
	orders[bIdx] = { mStock, mQuantity, mPrice, TYPE_BUY };

	while (1) {
		if (orders[bIdx].quantity == INVALID_ORDER)
			break;

		int sIdx = findSellOrder(mStock, mPrice);
		if (sIdx == -1)
			break;

		conclude(bIdx, sIdx, TYPE_BUY);

		if (orders[sIdx].quantity != INVALID_ORDER)
			sellQueue[mStock].push({ orders[sIdx].price, sIdx });
	}

	if (orders[bIdx].quantity != INVALID_ORDER)
		buyQueue[mStock].push({ mPrice, mNumber });

	return orders[bIdx].quantity;
}



int sell(int mNumber, int mStock, int mQuantity, int mPrice) {
	int sIdx = mNumber;
	orders[sIdx] = { mStock, mQuantity, mPrice, TYPE_SELL };

	while (1) {
		if (orders[sIdx].quantity == INVALID_ORDER)
			break;

		int bIdx = findBuyOrder(mStock, mPrice);
		if (bIdx == -1)
			break;

		conclude(bIdx, sIdx, TYPE_SELL);

		if (orders[bIdx].quantity != INVALID_ORDER)
			buyQueue[mStock].push({ orders[bIdx].price, bIdx });
	}

	if (orders[sIdx].quantity != INVALID_ORDER)
		sellQueue[mStock].push({ mPrice, mNumber });

	return orders[sIdx].quantity;
}


void cancel(int mNumber)
{
	orders[mNumber].quantity = INVALID_ORDER;
}


int bestProfit(int mStock)
{
	return maxProfit[mStock];
}
```

### [이현웅] 우선순위 큐

```cpp
#define MAX_STOCK 5
#define MAX_ORDER 200000
 
 struct orderInfo
 {
     int price;
     int quantity;
 };
 struct Data
 {
     int idx;
     int price;
     unsigned long long value;
 };
 
 struct Order
 {
     int minPrice[MAX_STOCK+1];
     int maxProfit[MAX_STOCK+1];
     orderInfo order[MAX_ORDER+1];
     void init()
     {
         for (int i = 0; i < MAX_STOCK+1; i++)
         {
             minPrice[i] = 10000000;
             maxProfit[i] = 0;
         }
     }
     void insertOrderInfo(int mNumber, int quantity, int mPrice)
     {
         order[mNumber].quantity = quantity;
         order[mNumber].price = mPrice;
     }
 }stockOrder;
 
 struct minPQ
 {
     Data heap[MAX_ORDER*2];
     int heapSize = 0;
     void heapInit(void)
     {
         heapSize = 0;
     }
     void heapPush(int idx, int price, unsigned long long value)
     {
         heap[heapSize].idx = idx;
         heap[heapSize].price = price;
         heap[heapSize].value = value;
         int current = heapSize;
         while (current > 0 && heap[current].value< heap[(current - 1) / 2].value)
         {
             Data temp = heap[(current - 1) / 2];
             heap[(current - 1) / 2] = heap[current];
             heap[current] = temp;
             current = (current - 1) / 2;
         }
         heapSize = heapSize + 1;
     }
 
     Data heapPop()
     {
         Data ret = heap[0];
         heapSize = heapSize - 1;
         heap[0] = heap[heapSize];
         int current = 0;
         while (current * 2 + 1 < heapSize)
         {
             int child;
             if (current * 2 + 2 == heapSize)
             {
                 child = current * 2 + 1;
             }
             else
             {
                 child = heap[current * 2 + 1].value < heap[current * 2 + 2].value ? current * 2 + 1 : current * 2 + 2;
             }
             if (heap[current].value < heap[child].value)
             {
                 break;
             }
             Data temp = heap[current];
             heap[current] = heap[child];
             heap[child] = temp;
             current = child;
         }
         return ret;
     }
 }stock_sell[MAX_STOCK+1];
 struct maxPQ
 {
     Data heap[MAX_ORDER *2];
     int heapSize = 0;
     void heapInit(void)
     {
         heapSize = 0;
     }
     void heapPush(int idx, int price, unsigned long long value)
     {
         heap[heapSize].idx = idx;
         heap[heapSize].price = price;
         heap[heapSize].value = value;
         int current = heapSize;
         while (current > 0 && heap[current].value > heap[(current - 1) / 2].value)
         {
             Data temp = heap[(current - 1) / 2];
             heap[(current - 1) / 2] = heap[current];
             heap[current] = temp;
             current = (current - 1) / 2;
         }
         heapSize = heapSize + 1;
     }
 
    Data heapPop()
     {
         Data ret;
         ret = heap[0];
         heapSize = heapSize - 1;
         heap[0] = heap[heapSize];
         int current = 0;
         while (current * 2 + 1 < heapSize)
         {
             int child;
             if (current * 2 + 2 == heapSize)
             {
                 child = current * 2 + 1;
             }
             else
             {
                 child = heap[current * 2 + 1].value > heap[current * 2 + 2].value ? current * 2 + 1 : current * 2 + 2;
             }
             if (heap[current].value > heap[child].value)
             {
                 break;
             }
            Data temp = heap[current];
            heap[current] = heap[child];
            heap[child] = temp;
            current = child;
         }
         return ret;
     }
 }stock_buy[MAX_STOCK+1];
 
 void init()
 {
     stockOrder.init();
     for (int i = 0; i < MAX_STOCK+1; i++)
     {
         stock_buy[i].heapInit();
         stock_sell[i].heapInit();
     }
 }
 
 int buy(int mNumber, int mStock, int mQuantity, int mPrice)
 {
     stockOrder.insertOrderInfo(mNumber, mQuantity, mPrice);
    while (stockOrder.order[mNumber].quantity > 0 && stock_sell[mStock].heapSize > 0 && stock_sell[mStock].heap[0].price <= mPrice)
    {
        Data data = stock_sell[mStock].heapPop();
        int idx = data.idx;
        int buyPrice = data.price;
        if (stockOrder.order[idx].quantity == 0) continue;
 
        if (stockOrder.order[idx].quantity <= stockOrder.order[mNumber].quantity)
        {
            stockOrder.order[mNumber].quantity -= stockOrder.order[idx].quantity;
            stockOrder.order[idx].quantity = 0;
        }
        else
        {
            stockOrder.order[idx].quantity -= stockOrder.order[mNumber].quantity;
            stockOrder.order[mNumber].quantity = 0;
            stock_sell[mStock].heapPush(idx, buyPrice, data.value);
        }
        if (stockOrder.minPrice[mStock] > buyPrice) stockOrder.minPrice[mStock] = buyPrice;
        stockOrder.maxProfit[mStock] = stockOrder.maxProfit[mStock] > (buyPrice - stockOrder.minPrice[mStock]) ? stockOrder.maxProfit[mStock] : (buyPrice - stockOrder.minPrice[mStock]);
    }
    if (stockOrder.order[mNumber].quantity > 0)
    {
        unsigned long long value = (unsigned long long )stockOrder.order[mNumber].price * 1000000 + (MAX_ORDER - mNumber);
        stock_buy[mStock].heapPush(mNumber, mPrice, value);
    }
     return stockOrder.order[mNumber].quantity;
 }
 
 int sell(int mNumber, int mStock, int mQuantity, int mPrice)
 {
     stockOrder.insertOrderInfo(mNumber, mQuantity, mPrice);
     while (stockOrder.order[mNumber].quantity > 0 && stock_buy[mStock].heapSize > 0 && stock_buy[mStock].heap[0].price >= mPrice)
     {
         Data data = stock_buy[mStock].heapPop();
         int idx = data.idx;
         int sellPrice = data.price;
         if (stockOrder.order[idx].quantity == 0) continue;
 
         if (stockOrder.order[idx].quantity <= stockOrder.order[mNumber].quantity)
         {
             stockOrder.order[mNumber].quantity -= stockOrder.order[idx].quantity;
             stockOrder.order[idx].quantity = 0;
         }
         else
         {
             stockOrder.order[idx].quantity -= stockOrder.order[mNumber].quantity;
             stockOrder.order[mNumber].quantity = 0;
             stock_buy[mStock].heapPush(idx, sellPrice, data.value);
         }
         if (stockOrder.minPrice[mStock] > sellPrice) stockOrder.minPrice[mStock] = sellPrice;
         stockOrder.maxProfit[mStock] = stockOrder.maxProfit[mStock] > (sellPrice - stockOrder.minPrice[mStock]) ? stockOrder.maxProfit[mStock] : (sellPrice - stockOrder.minPrice[mStock]);
     }
     if (stockOrder.order[mNumber].quantity > 0)
     {
         unsigned long long value = (unsigned long long)stockOrder.order[mNumber].price * 1000000 + mNumber;
         stock_sell[mStock].heapPush(mNumber, mPrice, value);
     }
     return stockOrder.order[mNumber].quantity;
 }
 
 void cancel(int mNumber)
 {
     stockOrder.order[mNumber].quantity = 0;
 }
 
 int bestProfit(int mStock)
 {
     return stockOrder.maxProfit[mStock];
 }
```

### [주재현] 우선순위 큐

```cpp
#include <queue>

using namespace std;

////////////////////////////////////////////////////////////////////////////////

const int MAX_ORDERS = 200003;
const int MAX_STOCKS = 6;
const int MAX_PRICE = 1000000;

enum TYPE
{
	TYPE_BUY,
	TYPE_SELL
};

/*
매수 주문은 주식을 사기 위한 주문, 매도 주문은 주식을 팔기 위한 주문을 의미한다.
주문에는 주문 번호, 주식 종목, 주문 수량, 희망 가격이 포함된다.
주문은 주문 번호로 구별된다.
*/
class Order
{
public:
	int orderid;
	int stockid;
	int quantity;
	int price;
	int version;
	int initquantity;
	bool bcancel;

	Order()
	{
		orderid = 0;
		stockid = 0;
		quantity = 0;
		price = 0;
		version = 0;
		initquantity = quantity;
		bcancel = false;
	}

	Order(int oid, int sid, int qty, int p)
	{
		orderid = oid;
		stockid = sid;
		quantity = qty;
		price = p;
		version = 0;
		initquantity = quantity;
		bcancel = false;
	}

	bool isPossibleToDeal(int sellprice)
	{
		return (price >= sellprice);
	}

	bool isCurrentVersion(int ver)
	{
		return (version == ver);
	}

	void tredeOrder(int dealqty)
	{
		quantity -= dealqty;
	}

	void updateVersion()
	{
		++version;
	}

	void cancelOrder()
	{
		bcancel = true;
	}
};

class Data
{
public:
	int price;
	int orderid;
	int version;
	int type;

	Data()
	{
		price = 0;
		orderid = 0;
		version = 0;
		type = TYPE_BUY;
	}

	Data(int p, int oid, int v, int ty)
	{
		price = p;
		orderid = oid;
		version = v;
		type = ty;
	}

	Data(const Order &o, int ty)
	{
		price = o.price;
		orderid = o.orderid;
		version = o.version;
		type = ty;
	}

	bool operator<(const Data &d) const
	{
		// 거래를 체결할 미체결 매수 주문은 매수 희망 가격이 높은 주문, 가격이 동일하다면
		// 주문 번호가 낮은 주문 순으로 선택한다.
		if (type == TYPE_BUY)
		{
			return (price < d.price
				|| price == d.price && orderid > d.orderid);
		}
		
		// 거래를 체결할 미체결 매도 주문은 매도 희망 가격이 낮은 주문, 가격이 동일하다면
		// 주문 번호가 낮은 주문 순으로 선택한다.
		return (price > d.price
			|| price == d.price && orderid > d.orderid);
	}
};

class Stock
{
public:
	int stockid;
	int maxprofit;
	int minprice;
	priority_queue<Data> sellorders;
	priority_queue<Data> buyorders;

	Stock()
	{
		stockid = 0;
		maxprofit = 0;
		minprice = MAX_PRICE;
		sellorders = priority_queue<Data>();
		buyorders = priority_queue<Data>();
	}

	Stock(int sid)
	{
		stockid = sid;
		maxprofit = 0;
		minprice = MAX_PRICE;
		sellorders = priority_queue<Data>();
		buyorders = priority_queue<Data>();
	}
};


////////////////////////////////////////////////////////////////////////////////

int numOfOrders = 0;

Order orders[MAX_ORDERS];
Stock stocks[MAX_STOCKS];


////////////////////////////////////////////////////////////////////////////////
void init()
{
	for (register int i = 1; i <= numOfOrders; ++i)
	{
		orders[i] = Order(i, 0, 0, 0);
	}

	numOfOrders = 0;

	for (register int i = 1; i < MAX_STOCKS; ++i)
	{
		stocks[i] = Stock(i);
	}
}

int buy(int mNumber, int mStock, int mQuantity, int mPrice)
{
	/*
	주문 번호가 mNumber인 매수 주문을 처리한다.
	mNumber 주문의 주식 종목은
	mStock, 주문 수량은 mQuantity, 매수 희망 가격은 mPrice이다.
	
	첫 주문 시 mNumber는 1이고, 이후 buy 혹은 sell 함수가 호출될 때마다 1씩 증가한다.
	*/
	orders[mNumber] = Order(mNumber, mStock, mQuantity, mPrice);
	Order &buyorder = orders[mNumber];
	Stock &stock = stocks[mStock];
	int rtn = -1;
	++numOfOrders;

	priority_queue<Data> &notsellorders = stock.sellorders;
	while (!notsellorders.empty())
	{
		Data d = notsellorders.top();
		notsellorders.pop();

		// 두 주문의 거래가 체결되기 위해선
		//매수 주문의 희망 가격이 매도 주문의 희망 가격 이상이어야 한다
		Order &sellorder = orders[d.orderid];
		if (!sellorder.isCurrentVersion(d.version))
		{
			continue;
		}

		if (!buyorder.isPossibleToDeal(sellorder.price))
		{
			notsellorders.push(d);
			break;
		}

		// 거래 시 체결되는 주문 수량은 두 주문의 남은 주문 수량 중 최솟값이며,
		// 체결 가격은 매도 주문의 희망 가격이다.
		int dealqty = min(buyorder.quantity, sellorder.quantity);
		int dealprice = sellorder.price;

		buyorder.tredeOrder(dealqty);
		sellorder.tredeOrder(dealqty);
		sellorder.updateVersion();

		if (sellorder.quantity > 0)
		{
			stock.sellorders.push(Data(sellorder, TYPE_SELL));
		}

		// 먼저 선택된 주문과의 거래가
		// 나중에 선택된 주문과의 거래보다 이른 시점에 체결된다.
		if (dealprice < stock.minprice)
		{
			stock.minprice = dealprice;
		}

		int diff = dealprice - stock.minprice;
		if (diff > stock.maxprofit)
		{
			stock.maxprofit = diff;
		}		

		// 미체결 매수 주문에 남은 mNumber 주문의 주문 수량을 반환한다.
		// mNumber 주문이 미체결 매수 주문에 남지 않는 경우, 0을 반환한다.
		rtn = buyorder.quantity;

		if (buyorder.quantity == 0)
		{
			break;
		}		
	}

	// mNumber 주문과 미체결 매도 주문들 사이의 거래를 체결한 후,
	// 남은 주문 수량을 미체결 매수 주문에 남긴다.
	if (buyorder.quantity > 0)
	{
		stock.buyorders.push(Data(buyorder, TYPE_BUY));
		rtn = buyorder.quantity;
	}

	return rtn;
}

int sell(int mNumber, int mStock, int mQuantity, int mPrice)
{
	/*
	매도 주문이 새로 들어오면 미체결 매수 주문들과 거래를 체결한다.
	
	주문 번호가 mNumber인 매도 주문을 처리한다.
	mNumber 주문의 주식 종목은 mStock, 주문 수량은 mQuantity, 매도 희망 가격은 mPrice이다.
	
	첫 주문 시 mNumber는 1이고, 이후 buy 혹은 sell 함수가 호출될 때마다 1씩 증가한다.
	*/
	orders[mNumber] = Order(mNumber, mStock, mQuantity, mPrice);
	Order &sellorder = orders[mNumber];
	Stock &stock = stocks[mStock];
	int rtn = -1;
	++numOfOrders;

	priority_queue<Data> &notbuyorders = stock.buyorders;
	while (!notbuyorders.empty())
	{
		Data d = notbuyorders.top();
		notbuyorders.pop();

		// 두 주문의 거래가 체결되기 위해선 매수 주문의 희망 가격이 매도 주문의 희망 가격 이상이어야 한다
		Order &buyorder = orders[d.orderid];
		if (!buyorder.isCurrentVersion(d.version))
		{
			continue;
		}

		if (!buyorder.isPossibleToDeal(sellorder.price))
		{
			notbuyorders.push(d);
			break;
		}

		// 거래 시 체결되는 주문 수량은 두 주문의 남은 주문 수량 중 최솟값이며,
		// 체결 가격은 매수 주문의 희망 가격이다.
		int dealqty = min(sellorder.quantity, buyorder.quantity);
		int dealprice = buyorder.price;

		sellorder.tredeOrder(dealqty);
		buyorder.tredeOrder(dealqty);
		buyorder.updateVersion();

		if (buyorder.quantity > 0)
		{
			stock.buyorders.push(Data(buyorder, TYPE_BUY));
		}

		// 먼저 선택된 주문과의 거래가 나중에 선택된 주문과의 거래보다 이른 시점에 체결된다.
		if (dealprice < stock.minprice)
		{
			stock.minprice = dealprice;
		}

		int diff = dealprice - stock.minprice;
		if (diff > stock.maxprofit)
		{
			stock.maxprofit = diff;
		}		

		// 미체결 매수 주문에 남은 mNumber 주문의 주문 수량을 반환한다.
		// mNumber 주문이 미체결 매도 주문에 남지 않는 경우, 0을 반환한다.
		rtn = sellorder.quantity;

		if (sellorder.quantity == 0)
		{
			break;
		}
	}

	// mNumber 주문과 미체결 매도 주문들 사이의 거래를 체결한 후,
	// 남은 주문 수량을 미체결 매수 주문에 남긴다.
	if (sellorder.quantity > 0)
	{
		stock.sellorders.push(Data(sellorder, TYPE_SELL));
		rtn = sellorder.quantity;
	}

	return rtn;
}

void cancel(int mNumber)
{
	/*
	프로그램은 미체결 주문을 취소할 수 있어야 한다.
	*/
	Order &order = orders[mNumber];

	order.cancelOrder();
	order.updateVersion();
}

int bestProfit(int mStock)
{
	/*
	(mStock 주식의 임의의 시점(B)에서의 체결 가격 – mStock 주식의 임의의 시점(A)에서의 체결 가격)의 최댓값
	단, 시점(B)는 함수 호출 시점 이전이어야 하며, 시점(A)는 시점(B) 이전이어야 한다.

	(mStock 주식의 임의의 시점(B)에서의 체결 가격 – mStock 주식의 임의의 시점(A)에서의 체결 가격) 의
	최댓값을 반환한다.
	단, 시점(B)는 bestProfit 함수 호출 시점 이전이어야 하며, 시점(A)는 시점(B) 이전이어야 한다.
	‘시점(B) 이전’은 ‘시점(B)’를 포함한다.
	
	buy 혹은 sell 함수가 한 번만 호출되었을 때에도, 여러 번의 거래 체결이 생길 수 있음에 유의하라.
	이 경우, 어떤 거래 체결이 더 이른 시점에 발생하는 지는 각 함수의 설명을 참조하라.
	
	mStock 주식의 거래 체결이 한 번 이상 있었음이 보장된다.
	*/
	Stock &stock = stocks[mStock];
	int rtn = stock.maxprofit;

	return rtn;
}
```
