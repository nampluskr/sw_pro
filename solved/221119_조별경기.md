## 221119_조별경기

### vector, unordered_map
```c
#include <unordered_map>
#include <vector>

using namespace std;

struct Player {
	int score;
	int teamID;
};

struct Team {
	int score;
	vector<int> playerIDs;
};


unordered_map<int, Player> players;
unordered_map<int, Team> teams;

/// /////////////////////////////////
void init(int N)
{
	players.clear();
	teams.clear();

	for (int id = 1; id <= N; id++) {
		players[id] = Player();
		players[id].score = 0;
		players[id].teamID = id;

		teams[id] = Team();
		teams[id].score = 0;
		teams[id].playerIDs.push_back(id);
	}
}


void updateScore(int mWinnerID, int mLoserID, int mScore)
{
	teams[players[mWinnerID].teamID].score += mScore;
	teams[players[mLoserID].teamID].score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
	int teamID_larger, teamID_smaller;

	if (teams[players[mPlayerA].teamID].playerIDs.size() > teams[players[mPlayerB].teamID].playerIDs.size()) {
		teamID_larger = players[mPlayerA].teamID;
		teamID_smaller = players[mPlayerB].teamID;
	}
	else {
		teamID_larger = players[mPlayerB].teamID;
		teamID_smaller = players[mPlayerA].teamID;
	}

	for (auto& pID : teams[teamID_smaller].playerIDs) {
		players[pID].teamID = teamID_larger;
		players[pID].score += teams[teamID_smaller].score - teams[teamID_larger].score;
		
		teams[teamID_larger].playerIDs.emplace_back(pID);
	}
}


int getScore(int mID)
{
	return players[mID].score + teams[players[mID].teamID].score;
}

```
