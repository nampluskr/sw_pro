## 221119_조별경기

### vector, unordered_map
```c
#include <unordered_map>
#include <vector>

using namespace std;

struct Player {
	int score;
	int teamID;
};

struct Team {
	int score;
	vector<int> playerIDs;
};


unordered_map<int, Player> players;
unordered_map<int, Team> teams;

/// /////////////////////////////////
void init(int N)
{
	players.clear();
	teams.clear();

	for (int id = 1; id <= N; id++) {
		players[id] = Player();
		players[id].score = 0;
		players[id].teamID = id;

		teams[id] = Team();
		teams[id].score = 0;
		teams[id].playerIDs.push_back(id);
	}
}


void updateScore(int mWinnerID, int mLoserID, int mScore)
{
	teams[players[mWinnerID].teamID].score += mScore;
	teams[players[mLoserID].teamID].score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
	int teamID_larger, teamID_smaller;

	if (teams[players[mPlayerA].teamID].playerIDs.size() > teams[players[mPlayerB].teamID].playerIDs.size()) {
		teamID_larger = players[mPlayerA].teamID;
		teamID_smaller = players[mPlayerB].teamID;
	}
	else {
		teamID_larger = players[mPlayerB].teamID;
		teamID_smaller = players[mPlayerA].teamID;
	}

	for (auto& pID : teams[teamID_smaller].playerIDs) {
		players[pID].teamID = teamID_larger;
		players[pID].score += teams[teamID_smaller].score - teams[teamID_larger].score;
		
		teams[teamID_larger].playerIDs.emplace_back(pID);
	}
}


int getScore(int mID)
{
	return players[mID].score + teams[players[mID].teamID].score;
}
```

## 조별 경기

### vector, unordered_map (WS: 889ms)

[int]
- vector, map (1529 ms)
- vector, unordered_map (WS: 889ms)
- vector, array (512ms)
- list, array (588ms)
- forward_list, array fill (500 ms)
- forward_list, array (487 ms)

[pointer]
- forward_list, array (xxx ms)


```c
#include <unordered_map>
#include <vector>

using namespace std;

struct Player {
	int score;
	int teamID;
};

struct Team {
	int score;
	vector<int> playerIDs;
};

unordered_map<int, Player> players;
unordered_map<int, Team> teams;

/// /////////////////////////////////
void init(int N)
{
	players.clear();
	teams.clear();

	for (int id = 1; id <= N; id++) {
		players[id] = Player();
		players[id].score = 0;
		players[id].teamID = id;

		teams[id] = Team();
		teams[id].score = 0;
		teams[id].playerIDs.push_back(id);
	}
}


void updateScore(int mWinnerID, int mLoserID, int mScore)
{
	teams[players[mWinnerID].teamID].score += mScore;
	teams[players[mLoserID].teamID].score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
	int teamID_larger, teamID_smaller;

	if (teams[players[mPlayerA].teamID].playerIDs.size() > teams[players[mPlayerB].teamID].playerIDs.size()) {
		teamID_larger = players[mPlayerA].teamID;
		teamID_smaller = players[mPlayerB].teamID;
	}
	else {
		teamID_larger = players[mPlayerB].teamID;
		teamID_smaller = players[mPlayerA].teamID;
	}

	for (auto& pID : teams[teamID_smaller].playerIDs) {
		players[pID].teamID = teamID_larger;
		players[pID].score += teams[teamID_smaller].score - teams[teamID_larger].score;
		
		teams[teamID_larger].playerIDs.push_back(pID);
	}
}


int getScore(int mID)
{
	return players[mID].score + teams[players[mID].teamID].score;
}

```

## array, list
```c
#include <array>
#include <list>

#define MAX_USERS 100003

using namespace std;


struct Player {
	int score;
	int teamID;
};

struct Team {
	int score;
	list<int> playerIDs;
};


array<Player, MAX_USERS> players;
array<Team, MAX_USERS> teams;

/// /////////////////////////////////
void init(int N)
{
	// players.fill({});	// array clear
	// teams.fill({});		// array clear

	for (int id = 1; id <= N; id++) {
		players[id] = Player();
		players[id].score = 0;
		players[id].teamID = id;

		teams[id] = Team();
		teams[id].score = 0;
		teams[id].playerIDs.emplace_back(id);
	}
}


void updateScore(int mWinnerID, int mLoserID, int mScore)
{
	teams[players[mWinnerID].teamID].score += mScore;
	teams[players[mLoserID].teamID].score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
	int teamID_larger, teamID_smaller;

	if (teams[players[mPlayerA].teamID].playerIDs.size() > teams[players[mPlayerB].teamID].playerIDs.size()) {
		teamID_larger = players[mPlayerA].teamID;
		teamID_smaller = players[mPlayerB].teamID;
	}
	else {
		teamID_larger = players[mPlayerB].teamID;
		teamID_smaller = players[mPlayerA].teamID;
	}

	for (const auto& pID : teams[teamID_smaller].playerIDs) {
		players[pID].teamID = teamID_larger;
		players[pID].score += teams[teamID_smaller].score - teams[teamID_larger].score;
	}

	teams[teamID_larger].playerIDs.splice(teams[teamID_larger].playerIDs.end(), teams[teamID_smaller].playerIDs);
}


int getScore(int mID)
{
	return players[mID].score + teams[players[mID].teamID].score;
}
```

## forward_list, array
```c
#include <array>
#include <forward_list>

#define MAX_USERS 100003

using namespace std;


struct Player {
	int score;
	int teamID;
};

struct Team {
	int score;
	forward_list<int> playerIDs;
	int n_players;
};


array<Player, MAX_USERS> players;
array<Team, MAX_USERS> teams;


/// /////////////////////////////////
void init(int N)
{
	// players.fill({});	// array clear
	// teams.fill({});		// array clear

	for (int id = 1; id <= N; id++) {
		players[id] = Player();
		players[id].score = 0;
		players[id].teamID = id;

		teams[id] = Team();
		teams[id].score = 0;
		teams[id].playerIDs.emplace_front(id);		// forward_list
		teams[id].n_players = 1;					// forward_list
	}
}


void updateScore(int mWinnerID, int mLoserID, int mScore)
{
	teams[players[mWinnerID].teamID].score += mScore;
	teams[players[mLoserID].teamID].score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
	int teamID_larger, teamID_smaller;

	if (teams[players[mPlayerA].teamID].n_players > teams[players[mPlayerB].teamID].n_players) {		// forward_list
		teamID_larger = players[mPlayerA].teamID;
		teamID_smaller = players[mPlayerB].teamID;
	}
	else {
		teamID_larger = players[mPlayerB].teamID;
		teamID_smaller = players[mPlayerA].teamID;
	}

	for (const auto& pID : teams[teamID_smaller].playerIDs) {
		players[pID].teamID = teamID_larger;
		players[pID].score += teams[teamID_smaller].score - teams[teamID_larger].score;

		// teams[teamID_larger].playerIDs.emplace_front(pID);
	}

	teams[teamID_larger].n_players += teams[teamID_smaller].n_players;
	teams[teamID_larger].playerIDs.splice_after(teams[teamID_larger].playerIDs.begin(), teams[teamID_smaller].playerIDs);	// forward_list
}


int getScore(int mID)
{
	return players[mID].score + teams[players[mID].teamID].score;
}
```

## [pointer] array, vector
```c
#include <vector>
#include <array>

using namespace std;

const int MAX_USER = 100003;

struct Group;
struct User;

struct User
{
    int score;
    Group* pGroup;
};


struct Group
{
    int score;
    vector<User*> pUserVec;
};

array<Group, MAX_USER> groups;
array<User, MAX_USER> users;


////////////////////////////////////////////////////////////////////////////////
void init(int N)
{
    for (int id = 1; id <= N; ++id) {
        users[id] = User();
        groups[id] = Group();

        users[id].score = 0;
        users[id].pGroup = &groups[id];

        groups[id].score = 0;
        groups[id].pUserVec.push_back(&users[id]);
    }
}

void updateScore(int mWinnerID, int mLoserID, int mScore)
{
    users[mWinnerID].pGroup->score += mScore;
    users[mLoserID].pGroup->score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
    Group *pGroup_larger, *pGroup_smaller;

    if (users[mPlayerA].pGroup->pUserVec.size() >= users[mPlayerB].pGroup->pUserVec.size()) {
        pGroup_larger = users[mPlayerA].pGroup;
        pGroup_smaller = users[mPlayerB].pGroup;
    }
    else {
        pGroup_larger = users[mPlayerB].pGroup;
        pGroup_smaller = users[mPlayerA].pGroup;
    }

    for (auto vec : pGroup_smaller->pUserVec)
    {
        vec->score -= pGroup_larger->score - pGroup_smaller->score;
        vec->pGroup = pGroup_larger;
        pGroup_larger->pUserVec.push_back(vec);
    }

    pGroup_smaller->pUserVec.clear();

}

int getScore(int mID)
{
    return users[mID].score + users[mID].pGroup->score;
}
```

### array, forward_list
```c
#include <array>
#include <forward_list>

using namespace std;

const int MAX_USER = 100003;

struct Group;
struct User;

struct User
{
    int score;
    Group* pGroup;
};


struct Group
{
    int score;
    forward_list<User*> pUserVec;
    int n_players;
};

array<Group, MAX_USER> groups;
array<User, MAX_USER> users;


////////////////////////////////////////////////////////////////////////////////
void init(int N)
{
    for (int id = 1; id <= N; ++id) {
        users[id] = User();
        groups[id] = Group();

        users[id].score = 0;
        users[id].pGroup = &groups[id];

        groups[id].score = 0;
        groups[id].pUserVec.emplace_front(&users[id]);
        groups[id].n_players = 1;
    }
}

void updateScore(int mWinnerID, int mLoserID, int mScore)
{
    users[mWinnerID].pGroup->score += mScore;
    users[mLoserID].pGroup->score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
    Group *pGroup_larger, *pGroup_smaller;

    if (users[mPlayerA].pGroup->n_players >= users[mPlayerB].pGroup->n_players) {
        pGroup_larger = users[mPlayerA].pGroup;
        pGroup_smaller = users[mPlayerB].pGroup;
    }
    else {
        pGroup_larger = users[mPlayerB].pGroup;
        pGroup_smaller = users[mPlayerA].pGroup;
    }

    for (auto vec : pGroup_smaller->pUserVec)
    {
        vec->score -= pGroup_larger->score - pGroup_smaller->score;
        vec->pGroup = pGroup_larger;
        //pGroup_larger->pUserVec.emplace_front(vec);
    }

    pGroup_larger->n_players += pGroup_smaller->n_players;
    //pGroup_smaller->pUserVec.clear();
    pGroup_larger->pUserVec.splice_after(pGroup_larger->pUserVec.begin(), pGroup_smaller->pUserVec);

}

int getScore(int mID)
{
    return users[mID].score + users[mID].pGroup->score;
}
```

### [pointer] array, list
```c
#include <array>
//#include <forward_list>
#include <list>

using namespace std;

const int MAX_USER = 100003;

struct Group;
struct User;

struct User
{
    int score;
    Group* pGroup;
};


struct Group
{
    int score;
    list<User*> pUserVec;
    int n_players;
};

array<Group, MAX_USER> groups;
array<User, MAX_USER> users;


////////////////////////////////////////////////////////////////////////////////
void init(int N)
{
    for (int id = 1; id <= N; ++id) {
        users[id] = User();
        groups[id] = Group();

        users[id].score = 0;
        users[id].pGroup = &groups[id];

        groups[id].score = 0;
        groups[id].pUserVec.emplace_back(&users[id]);
        //groups[id].n_players = 1;
    }
}

void updateScore(int mWinnerID, int mLoserID, int mScore)
{
    users[mWinnerID].pGroup->score += mScore;
    users[mLoserID].pGroup->score -= mScore;
}


void unionTeam(int mPlayerA, int mPlayerB)
{
    Group *pGroup_larger, *pGroup_smaller;

    if (users[mPlayerA].pGroup->pUserVec.size() >= users[mPlayerB].pGroup->pUserVec.size()) {
        pGroup_larger = users[mPlayerA].pGroup;
        pGroup_smaller = users[mPlayerB].pGroup;
    }
    else {
        pGroup_larger = users[mPlayerB].pGroup;
        pGroup_smaller = users[mPlayerA].pGroup;
    }

    for (auto vec : pGroup_smaller->pUserVec)
    {
        vec->score -= pGroup_larger->score - pGroup_smaller->score;
        vec->pGroup = pGroup_larger;
        //pGroup_larger->pUserVec.emplace_back(vec);
    }

    //pGroup_larger->n_players += pGroup_smaller->n_players;
    //pGroup_smaller->pUserVec.clear();
    pGroup_larger->pUserVec.splice(pGroup_larger->pUserVec.end(), pGroup_smaller->pUserVec);

}

int getScore(int mID)
{
    return users[mID].score + users[mID].pGroup->score;
}
```


### main.cpp
```c
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <time.h>

#define CMD_INIT 100
#define CMD_UPDATE_SCORE 200
#define CMD_UNION_TEAM 300
#define CMD_GET_SCORE 400

extern void init(int N);
extern void updateScore(int mWinnerID, int mLoserID, int mScore);
extern void unionTeam(int mPlayerA, int mPlayerB);
extern int getScore(int mID);


static bool run()
{
	int queryCnt, cmd;
	int ans, res;
	bool okay = false;
	scanf("%d", &queryCnt);

	for (int i = 0; i < queryCnt; i++)
	{
		scanf("%d", &cmd);

		switch (cmd)
		{
		case CMD_INIT:
			int N;
			scanf("%d", &N);
			init(N);
			okay = true;
			break;

		case CMD_UPDATE_SCORE:
			int mWinnerID, mLoserID, mScore;
			scanf("%d%d%d", &mWinnerID, &mLoserID, &mScore);
			updateScore(mWinnerID, mLoserID, mScore);
			break;

		case CMD_UNION_TEAM:
			int mPlayerA, mPlayerB;
			scanf("%d%d", &mPlayerA, &mPlayerB);
			unionTeam(mPlayerA, mPlayerB);
			break;

		case CMD_GET_SCORE:
			int mID;
			scanf("%d", &mID);
			res = getScore(mID);
			scanf("%d", &ans);

			if (ans != res)
			{
				okay = false;
			}
			break;
		}
	}
	return okay;
}


int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input.txt", "r", stdin);

	int T, MARK;
	scanf("%d%d", &T, &MARK);

	for (int tc = 1; tc <= T; tc++)
	{
		int score = run() ? MARK : 0;
		printf("#%d %d\n", tc, score);
	}

	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf("Result: %d ms\n", result);

	return 0;
}
```
