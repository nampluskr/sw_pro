## 220708_주차장

### [main.py]

```c
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <time.h>

extern void init(int mBaseTime, int mBaseFee, int mUnitTime, int mUnitFee, int mCapacity);
extern int arrive(int mTime, int mCar);
extern int leave(int mTime, int mCar);

/////////////////////////////////////////////////////////////////////////
#define CMD_INIT 1
#define CMD_ARRIVE 2
#define CMD_LEAVE 3

static bool run() {
	int q;
	scanf("%d", &q);

	int basetime, basefee, unittime, unitfee, capacity, mtime, mcar;
	int cmd, ans, ret = 0;
	bool okay = false;

	for (int i = 0; i < q; ++i) {
		scanf("%d", &cmd);
		switch (cmd) {
		case CMD_INIT:
			scanf("%d %d %d %d %d", &basetime, &basefee, &unittime, &unitfee, &capacity);
			init(basetime, basefee, unittime, unitfee, capacity);
			okay = true;
			break;

		case CMD_ARRIVE:
			scanf("%d %d %d", &mtime, &mcar, &ans);
			ret = arrive(mtime, mcar);
			if (ans != ret)
				okay = false;
			break;

		case CMD_LEAVE:
			scanf("%d %d %d", &mtime, &mcar, &ans);
			ret = leave(mtime, mcar);
			if (ans != ret)
				okay = false;
			break;

		default:
			okay = false;
			break;
		}
	}
	return okay;
}


int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input.txt", "r", stdin);

	int T, MARK;
	scanf("%d %d", &T, &MARK);

	for (int tc = 1; tc <= T; tc++) {
		int score = run() ? MARK : 0;
		printf("#%d %d\n", tc, score);
	}
	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf("Result: %d ms\n", result);
	return 0;
}
```

### [solution.py] Ref.

```c
// 강규영 373 ms
#define MAX_PARKING_CAPA	201
#define MAX_CAR		70001
#define MAX_SIZE 100000

#define NONE	0
#define WAIT	1
#define PARKING	2


struct ListNode
{
	int Idx;
	ListNode* next;
};

int hrp;
ListNode heap[1000000];


ListNode* AppendListNode(int Idx, ListNode* next)
{
	ListNode* node = &heap[hrp++];
	node->Idx = Idx;
	node->next = next;

	return node;
}

ListNode* car_List[MAX_CAR];

struct Data
{
	int Idx;
	int priority;
	unsigned long long value;
};

struct MAXHEAP
{
	Data heap[MAX_SIZE];
	int heapSize = 0;

	bool datacmp(Data data1, Data data2)
	{
		if (data1.value < data2.value) return true;
		else if (data1.value == data2.value && data1.priority < data2.priority) return true;
		return false;
	}

	void heapInit(void)
	{
		heapSize = 0;
	}

	int heapPush(int Idx, int value, int priority)
	{
		heap[heapSize].Idx = Idx;
		heap[heapSize].value = value;
		heap[heapSize].priority = priority;

		int current = heapSize;

		while (current > 0 && datacmp(heap[current], heap[(current - 1) / 2]))
		{
			Data temp = heap[(current - 1) / 2];
			heap[(current - 1) / 2] = heap[current];
			heap[current] = temp;
			current = (current - 1) / 2;
		}

		heapSize = heapSize + 1;
		return 1;
	}

	Data heapPop()
	{
		Data value = heap[0];
		heapSize = heapSize - 1;
		heap[0] = heap[heapSize];

		int current = 0;
		while (current * 2 + 1 < heapSize)
		{
			int child;
			if (current * 2 + 2 == heapSize)
			{
				child = current * 2 + 1;
			}
			else
			{
				child = datacmp(heap[current * 2 + 1], heap[current * 2 + 2]) ? current * 2 + 1 : current * 2 + 2;
			}

			if (datacmp(heap[current], heap[child]))
			{
				break;
			}

			Data temp = heap[current];
			heap[current] = heap[child];
			heap[child] = temp;
			current = child;
		}
		return value;
	}
};

MAXHEAP max_wait_priority;

struct CAR_INFO
{
	int mCar;
	int state;
	int parking_arrive_time;
	int total_parking_time;
	int total_wait_time;
};

CAR_INFO car_info[MAX_CAR];

struct PARKING_LOT_INFO
{
	int mBaseTime;
	int mBaseFee;
	int mUnitTime;
	int mUnitFee;
	int mCapacity;
	int wait_cnt;
	int parking_cnt;
};

PARKING_LOT_INFO parking_lot_info;

int current_time;
int car_cnt;

////////////////////////////////////////////////////////
void init(int mBaseTime, int mBaseFee, int mUnitTime, int mUnitFee, int mCapacity)
{
	current_time = 0;
	parking_lot_info.wait_cnt = 0;
	parking_lot_info.parking_cnt = 0;
	car_cnt = 0;  // 한번이라도 방문 등록된 차량의 댓수
	max_wait_priority.heapInit();

	for (int i = 0; i < MAX_CAR; i++)
	{
		car_info[i].state = NONE;
		car_info[i].parking_arrive_time = -1;
		car_info[i].total_parking_time = 0;
		car_info[i].total_wait_time = 0;
		car_List[i] = 0;
	}
	parking_lot_info.mBaseTime = mBaseTime;
	parking_lot_info.mBaseFee = mBaseFee;
	parking_lot_info.mUnitTime = mUnitTime;
	parking_lot_info.mUnitFee = mUnitFee;
	parking_lot_info.mCapacity = mCapacity;

	return;
}


int get_car_Idx(int mCar)
{
	int hashkey = mCar % MAX_CAR;
	ListNode* temp = car_List[hashkey];

	while (temp != 0)
	{
		int Idx = temp->Idx;
		if (car_info[Idx].mCar == mCar) return Idx;
		temp = temp->next;
	}
	return -1;
}

int arrive(int mTime, int mCar)
{
	current_time = mTime;
	int car_Idx = get_car_Idx(mCar);

	if (car_Idx == -1)  // 신규로 등록이 필요한 차라면
	{
		car_info[car_cnt].mCar = mCar;
		car_info[car_cnt].state = NONE;
		car_info[car_cnt].parking_arrive_time = current_time;
		car_info[car_cnt].total_parking_time = 0;
		car_info[car_cnt].total_wait_time = 0;

		int hashkey = mCar % MAX_CAR;
		car_List[hashkey] = AppendListNode(car_cnt, car_List[hashkey]);
		car_Idx = car_cnt;
		car_cnt++;
	}
	else  // 신규 등록이 아니라면
	{
		car_info[car_Idx].parking_arrive_time = current_time;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (parking_lot_info.mCapacity - parking_lot_info.parking_cnt <= 0) // 주차할 공간이 없으므로 대기열에 입력 시킨다.
	{
		car_info[car_Idx].state = WAIT;
		unsigned long long value = current_time - (car_info[car_Idx].total_wait_time - car_info[car_Idx].total_parking_time);
		max_wait_priority.heapPush(car_Idx, value, mTime);
		parking_lot_info.wait_cnt++;
	}
	else  // 주차 등록 시킨다.
	{
		car_info[car_Idx].state = PARKING;
		parking_lot_info.parking_cnt++;
	}
	return  parking_lot_info.wait_cnt;
}


int cost_cal(int parking_start_time)
{
	int result_cost = 0;
	int parking_time = current_time - parking_start_time;
	parking_time -= parking_lot_info.mBaseTime;
	result_cost += parking_lot_info.mBaseFee;

	if (parking_time > 0) // 기준시간 이상으로 주차를 했다면
	{
		int unit_parking_time = parking_time / parking_lot_info.mUnitTime;
		result_cost += unit_parking_time * parking_lot_info.mUnitFee;

		if (parking_time % parking_lot_info.mUnitTime > 0)
		{
			result_cost += parking_lot_info.mUnitFee;
		}
	}
	return result_cost;
}

int leave(int mTime, int mCar)
{
	int cost = -1;
	current_time = mTime;
	int car_Idx = get_car_Idx(mCar);

	if (car_info[car_Idx].state == PARKING)  // 주차 하고 있으면 상태 정보 변경 및 주차비를 계산한다.
	{
		cost = cost_cal(car_info[car_Idx].parking_arrive_time);
		parking_lot_info.parking_cnt--;
		car_info[car_Idx].state = NONE;
		car_info[car_Idx].total_parking_time += current_time - car_info[car_Idx].parking_arrive_time;
		car_info[car_Idx].parking_arrive_time = 0;
	}
	else  // 주차 하고 있지 않으면 현재까지 대기시간을 계산해주고 상태 변경을 해준다.
	{
		parking_lot_info.wait_cnt--;
		car_info[car_Idx].state = NONE;
		car_info[car_Idx].total_wait_time += current_time - car_info[car_Idx].parking_arrive_time;
		car_info[car_Idx].parking_arrive_time = 0;
	}

	while (max_wait_priority.heapSize > 0 && parking_lot_info.wait_cnt > 0 && parking_lot_info.mCapacity - parking_lot_info.parking_cnt > 0)
	{
		Data temp = max_wait_priority.heapPop();
		int temp_car_Idx = temp.Idx;

		if (car_info[temp_car_Idx].state != WAIT) continue;
		if (car_info[temp_car_Idx].parking_arrive_time != temp.priority) continue;

		car_info[temp_car_Idx].state = PARKING;
		car_info[temp_car_Idx].total_wait_time += current_time - car_info[temp_car_Idx].parking_arrive_time;
		car_info[temp_car_Idx].parking_arrive_time = current_time;
		parking_lot_info.wait_cnt--;
		parking_lot_info.parking_cnt++;
	}
	return cost;
}
```

### [작성중] 

```c
// mTime: 도착/출발 시각(1 ≤ mTime ≤ 300,000) 30만 => 증가하는 값으로 주어진다.
// mCar : 차량 번호(1 ≤ mCar ≤ 1,000,000,000) 10억
// 차량상태: 주차중 / 대기중 /  신규
// 차량 우선순위: 1. (총 대기시간 - 총 주차시간) 클수록 2. 대기열에 추가 시간이 빠를수록
// 모든 함수의 호출 횟수 총합은 100,000 이하

#include <vector>
#include <unordered_map>
#include <queue>
#include <math.h>

using namespace std;

#define WAITING 0			// cars[idx].state
#define PARKING 1			// cars[idx].state
#define LEFT   -1			// cars[idx].state

struct Car {
	int id;
	int parkingStartTime;
	int waitingStartTime;
	int totalParkingTime;
	int totalWaitingTime;
	int state;				// WAITING, PARKING, LEFT
	int priorityValue;		// totalParkingtime - totalWaitingTime - mTime

	bool operator()(const Car& c1, const Car& c2) {
		if (c1.priorityValue < c2.priorityValue)
			return true;
		if (c1.priorityValue == c2.priorityValue && c1.waitingStartTime > c2.waitingStartTime)
			return true;
		return false;
	}
};

struct ParkingLot {
	int baseTime, baseFee, unitTime, unitFee;
	int capacity;

	int n_parkingCars;
	int n_waitingCars;

	int get_parkingFee(int parkingTime) {
		int fee = this->baseFee;
		if (parkingTime > this->baseTime) {
			fee = this->baseFee + ceil((parkingTime - this->baseTime) / this->unitTime) * this->unitFee;
		}
		return fee;
	}
};

unordered_map<int, int> mapCarID;			// idx = mapCarID[mCar]
vector<Car> cars;							// cars[idx]
priority_queue<Car, vector<Car>, Car> waintingCars;
ParkingLot parkinglot;

/////////////////////////////////////////////////////////////////////////////////////////////

// 주차장 정보 초기화
// 주차요금 = 기본요금 + ceil((주차시간 - 기본시간) / 단위시간) * 단위요금
void init(int mBaseTime, int mBaseFee, int mUnitTime, int mUnitFee, int mCapacity)
{
	parkinglot.baseTime = mBaseTime;
	parkinglot.baseFee = mBaseFee;
	parkinglot.unitTime = mUnitTime;
	parkinglot.unitFee = mUnitFee;
	parkinglot.capacity = mCapacity;
	parkinglot.n_parkingCars = 0;
	parkinglot.n_waitingCars = 0;

	mapCarID.clear();
	cars.clear();

	while (not waintingCars.empty()) {
		waintingCars.pop();
	}
}

// mTime 시각에 mCar가 도착한다. => 대기 중인 차량의 개수를 반환한다.
// mCar가 주차 중이거나 대기 중인 차량 번호로 주어지는 경우는 없다.
// 주차장의 용량이 남아 있다면 입차 시키고, 그렇지 않다면 대기열에 추가한다.
// 주차장을 방문했던 차량이 다시 방문할 수 있음을 유의하라.
// 호출회수: 70,000
int arrive(int mTime, int mCar)
{
	// 처음 주차장에 오는 차일 경우 => 차량 생성
	if (mapCarID.count(mCar) == 0) {
		mapCarID[mCar] = cars.size();
		cars.push_back(Car());
	}
	int idx = mapCarID[mCar];

	// 주차공간이 있으면 => 주차 시작
	if (parkinglot.n_parkingCars < parkinglot.capacity) {
		cars[idx].state = PARKING;
		cars[idx].parkingStartTime = mTime;
		parkinglot.n_parkingCars += 1;
	}
	// 주차공간이 없으면 => 대기 시작 / 우큐에 저장
	else {
		cars[idx].state = WAITING;
		cars[idx].waitingStartTime = mTime;
		parkinglot.n_waitingCars += 1;

		cars[idx].priorityValue = cars[idx].totalWaitingTime - cars[idx].totalParkingTime - mTime;
		waintingCars.push(cars[idx]);		// 객체 복사 저장 (동기화 필요)
	}

	return parkinglot.n_waitingCars;
}

// mTime 시각에 mCar가 출발한다.
// mCar는 주차 중이거나 대기 중인 차량 번호로만 주어진다.
// mCar가 주차 중이었다면 주차 요금을 반환한다.
// 대기 차량 중에서(총 대기 시간 - 총 주차 시간)이 가장 큰 차량을 주차장에 입차 시킨다.
// 만약에(총 대기 시간 - 총 주차 시간)이 가장 큰 차량이 2대 이상이라면, 대기열에 먼저 추가된 차량을 입차 시킨다. 
// (대기열에 A 차량, B 차량 순서로 추가된 후에 A 차량이 대기열에서 삭제되고 다시 추가된다면, 
// B 차량이 A 차량보다 대기열에 먼저 추가된 차량으로 처리됨을 유의하라)
// mCar가 대기 중이었다면 대기열에서 삭제하고 - 1을 반환한다.
int leave(int mTime, int mCar)
{
	int idx = mapCarID[mCar];

	// 주차중인 차일 경우 => 요금 정산
	if (cars[idx].state = PARKING) {
		cars[idx].state = LEFT;
		cars[idx].totalParkingTime += mTime - cars[idx].parkingStartTime;
		parkinglot.n_parkingCars -= 1;

		// 대기 차량이 있으면 => 주차 시킴
		while (not waintingCars.empty()) {
			Car c = waintingCars.top(); waintingCars.pop();
			int widx = mapCarID[c.id];

			if (c.state == WAITING && c.waitingStartTime == cars[widx].waitingStartTime) {
				cars[widx].state = PARKING;
				cars[widx].parkingStartTime = mTime;
				parkinglot.n_parkingCars += 1;

				cars[widx].totalWaitingTime+= mTime - cars[widx].waitingStartTime;
				parkinglot.n_waitingCars -= 1;
				break;
			}
		}
		return parkinglot.get_parkingFee(mTime - cars[idx].parkingStartTime);
	}

	// 대기중인 차일 경우 => 대기 정보 업데이트
	if (cars[idx].state == WAITING) {
		cars[idx].state = LEFT;
		cars[idx].totalWaitingTime += mTime - cars[idx].waitingStartTime;

		return -1;
	}
}
```

### 우선순위 큐 예제

```cpp
#include <iostream>
#include <unordered_map>
#include <vector>
#include <queue>
#include <string>

using namespace std;

struct Person {
	string id;
	string name;
	int age;
	int state;

	Person() {
		this->id = "";
		this->name = "";
		this->age = 0;
		this->state = 0;
	}
	Person(string id, string name, int age) {
		this->id = id;
		this->name = name;
		this->age = age;
		this->state = 1;
	}
	bool operator()(const Person& p1, const Person& p2) {
		if (p1.age < p2.age)	// 나이가 클수록
			return true;
		if (p1.age == p2.age && p1.name > p2.name) // 이름이 사전순 빠를수록
			return true;
		return false;
	}
};

unordered_map<string, int> index;			// idx = index[mID]
vector<Person> persons;						// persons[idx]
priority_queue<Person, vector<Person>, Person> pq;


void init()
{
	index.clear();
	persons.clear();
	while (not pq.empty())
		pq.pop();
}

void print_all()
{
	if (persons.size() > 0) {
		for (auto& p : persons) {
			printf(">> ID: %s, Name: %s, Age: %d, state=%d\n", 
				p.id.c_str(), p.name.c_str(), p.age, p.state);
		}
		printf("\n");
	}
}

void add(string mID, string mName, int mAge)
{
	int idx = persons.size();
	index[mID] = idx;
	persons.push_back(Person(mID, mName, mAge));
	pq.push(persons[idx]);
}

void del(string mID) 
{
	persons[index[mID]].state = 0;
}

int main()
{
	init();
	add("P101", "Kim2", 19);
	add("P102", "Kim1", 25);
	add("P103", "Kim3", 11);
	add("P104", "Kim4", 26);

	print_all();

	del("P104");

	print_all();
	
	Person p = pq.top();
	printf(">> ID: %s, Name: %s, Age: %d, state=%d\n",
		p.id.c_str(), p.name.c_str(), p.age, p.state);

	p = persons[index[p.id]];
	printf(">> ID: %s, Name: %s, Age: %d, state=%d\n",
		p.id.c_str(), p.name.c_str(), p.age, p.state);


	return 0;
}
```
