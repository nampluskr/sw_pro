## 220708_주차장

### [main.py]

```c
#ifndef _CRT_SECURE_NO_WARNINGS
#define _CRT_SECURE_NO_WARNINGS
#endif

#include <stdio.h>
#include <time.h>

extern void init(int mBaseTime, int mBaseFee, int mUnitTime, int mUnitFee, int mCapacity);
extern int arrive(int mTime, int mCar);
extern int leave(int mTime, int mCar);

/////////////////////////////////////////////////////////////////////////
#define CMD_INIT 1
#define CMD_ARRIVE 2
#define CMD_LEAVE 3

static bool run() {
	int q;
	scanf("%d", &q);

	int basetime, basefee, unittime, unitfee, capacity, mtime, mcar;
	int cmd, ans, ret = 0;
	bool okay = false;

	for (int i = 0; i < q; ++i) {
		scanf("%d", &cmd);
		switch (cmd) {
		case CMD_INIT:
			scanf("%d %d %d %d %d", &basetime, &basefee, &unittime, &unitfee, &capacity);
			init(basetime, basefee, unittime, unitfee, capacity);
			okay = true;
			break;

		case CMD_ARRIVE:
			scanf("%d %d %d", &mtime, &mcar, &ans);
			ret = arrive(mtime, mcar);
			if (ans != ret)
				okay = false;
			break;

		case CMD_LEAVE:
			scanf("%d %d %d", &mtime, &mcar, &ans);
			ret = leave(mtime, mcar);
			if (ans != ret)
				okay = false;
			break;

		default:
			okay = false;
			break;
		}
	}
	return okay;
}


int main()
{
	clock_t start = clock();

	setbuf(stdout, NULL);
	freopen("sample_input.txt", "r", stdin);

	int T, MARK;
	scanf("%d %d", &T, &MARK);

	for (int tc = 1; tc <= T; tc++) {
		int score = run() ? MARK : 0;
		printf("#%d %d\n", tc, score);
	}
	int result = (clock() - start) / (CLOCKS_PER_SEC / 1000);
	printf("Result: %d ms\n", result);
	return 0;
}
```

### [solution.py] Ref.

```c
// 강규영 373 ms
#define MAX_PARKING_CAPA	201
#define MAX_CAR		70001
#define MAX_SIZE 100000

#define NONE	0
#define WAIT	1
#define PARKING	2


struct ListNode
{
	int Idx;
	ListNode* next;
};

int hrp;
ListNode heap[1000000];


ListNode* AppendListNode(int Idx, ListNode* next)
{
	ListNode* node = &heap[hrp++];
	node->Idx = Idx;
	node->next = next;

	return node;
}

ListNode* car_List[MAX_CAR];

struct Data
{
	int Idx;
	int priority;
	unsigned long long value;
};

struct MAXHEAP
{
	Data heap[MAX_SIZE];
	int heapSize = 0;

	bool datacmp(Data data1, Data data2)
	{
		if (data1.value < data2.value) return true;
		else if (data1.value == data2.value && data1.priority < data2.priority) return true;
		return false;
	}

	void heapInit(void)
	{
		heapSize = 0;
	}

	int heapPush(int Idx, int value, int priority)
	{
		heap[heapSize].Idx = Idx;
		heap[heapSize].value = value;
		heap[heapSize].priority = priority;

		int current = heapSize;

		while (current > 0 && datacmp(heap[current], heap[(current - 1) / 2]))
		{
			Data temp = heap[(current - 1) / 2];
			heap[(current - 1) / 2] = heap[current];
			heap[current] = temp;
			current = (current - 1) / 2;
		}

		heapSize = heapSize + 1;
		return 1;
	}

	Data heapPop()
	{
		Data value = heap[0];
		heapSize = heapSize - 1;
		heap[0] = heap[heapSize];

		int current = 0;
		while (current * 2 + 1 < heapSize)
		{
			int child;
			if (current * 2 + 2 == heapSize)
			{
				child = current * 2 + 1;
			}
			else
			{
				child = datacmp(heap[current * 2 + 1], heap[current * 2 + 2]) ? current * 2 + 1 : current * 2 + 2;
			}

			if (datacmp(heap[current], heap[child]))
			{
				break;
			}

			Data temp = heap[current];
			heap[current] = heap[child];
			heap[child] = temp;
			current = child;
		}
		return value;
	}
};

MAXHEAP max_wait_priority;

struct CAR_INFO
{
	int mCar;
	int state;
	int parking_arrive_time;
	int total_parking_time;
	int total_wait_time;
};

CAR_INFO car_info[MAX_CAR];

struct PARKING_LOT_INFO
{
	int mBaseTime;
	int mBaseFee;
	int mUnitTime;
	int mUnitFee;
	int mCapacity;
	int wait_cnt;
	int parking_cnt;
};

PARKING_LOT_INFO parking_lot_info;

int current_time;
int car_cnt;

////////////////////////////////////////////////////////
void init(int mBaseTime, int mBaseFee, int mUnitTime, int mUnitFee, int mCapacity)
{
	current_time = 0;
	parking_lot_info.wait_cnt = 0;
	parking_lot_info.parking_cnt = 0;
	car_cnt = 0;  // 한번이라도 방문 등록된 차량의 댓수
	max_wait_priority.heapInit();

	for (int i = 0; i < MAX_CAR; i++)
	{
		car_info[i].state = NONE;
		car_info[i].parking_arrive_time = -1;
		car_info[i].total_parking_time = 0;
		car_info[i].total_wait_time = 0;
		car_List[i] = 0;
	}
	parking_lot_info.mBaseTime = mBaseTime;
	parking_lot_info.mBaseFee = mBaseFee;
	parking_lot_info.mUnitTime = mUnitTime;
	parking_lot_info.mUnitFee = mUnitFee;
	parking_lot_info.mCapacity = mCapacity;

	return;
}


int get_car_Idx(int mCar)
{
	int hashkey = mCar % MAX_CAR;
	ListNode* temp = car_List[hashkey];

	while (temp != 0)
	{
		int Idx = temp->Idx;
		if (car_info[Idx].mCar == mCar) return Idx;
		temp = temp->next;
	}
	return -1;
}

int arrive(int mTime, int mCar)
{
	current_time = mTime;
	int car_Idx = get_car_Idx(mCar);

	if (car_Idx == -1)  // 신규로 등록이 필요한 차라면
	{
		car_info[car_cnt].mCar = mCar;
		car_info[car_cnt].state = NONE;
		car_info[car_cnt].parking_arrive_time = current_time;
		car_info[car_cnt].total_parking_time = 0;
		car_info[car_cnt].total_wait_time = 0;

		int hashkey = mCar % MAX_CAR;
		car_List[hashkey] = AppendListNode(car_cnt, car_List[hashkey]);
		car_Idx = car_cnt;
		car_cnt++;
	}
	else  // 신규 등록이 아니라면
	{
		car_info[car_Idx].parking_arrive_time = current_time;
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (parking_lot_info.mCapacity - parking_lot_info.parking_cnt <= 0) // 주차할 공간이 없으므로 대기열에 입력 시킨다.
	{
		car_info[car_Idx].state = WAIT;
		unsigned long long value = current_time - (car_info[car_Idx].total_wait_time - car_info[car_Idx].total_parking_time);
		max_wait_priority.heapPush(car_Idx, value, mTime);
		parking_lot_info.wait_cnt++;
	}
	else  // 주차 등록 시킨다.
	{
		car_info[car_Idx].state = PARKING;
		parking_lot_info.parking_cnt++;
	}
	return  parking_lot_info.wait_cnt;
}


int cost_cal(int parking_start_time)
{
	int result_cost = 0;
	int parking_time = current_time - parking_start_time;
	parking_time -= parking_lot_info.mBaseTime;
	result_cost += parking_lot_info.mBaseFee;

	if (parking_time > 0) // 기준시간 이상으로 주차를 했다면
	{
		int unit_parking_time = parking_time / parking_lot_info.mUnitTime;
		result_cost += unit_parking_time * parking_lot_info.mUnitFee;

		if (parking_time % parking_lot_info.mUnitTime > 0)
		{
			result_cost += parking_lot_info.mUnitFee;
		}
	}
	return result_cost;
}

int leave(int mTime, int mCar)
{
	int cost = -1;
	current_time = mTime;
	int car_Idx = get_car_Idx(mCar);

	if (car_info[car_Idx].state == PARKING)  // 주차 하고 있으면 상태 정보 변경 및 주차비를 계산한다.
	{
		cost = cost_cal(car_info[car_Idx].parking_arrive_time);
		parking_lot_info.parking_cnt--;
		car_info[car_Idx].state = NONE;
		car_info[car_Idx].total_parking_time += current_time - car_info[car_Idx].parking_arrive_time;
		car_info[car_Idx].parking_arrive_time = 0;
	}
	else  // 주차 하고 있지 않으면 현재까지 대기시간을 계산해주고 상태 변경을 해준다.
	{
		parking_lot_info.wait_cnt--;
		car_info[car_Idx].state = NONE;
		car_info[car_Idx].total_wait_time += current_time - car_info[car_Idx].parking_arrive_time;
		car_info[car_Idx].parking_arrive_time = 0;
	}

	while (max_wait_priority.heapSize > 0 && parking_lot_info.wait_cnt > 0 && parking_lot_info.mCapacity - parking_lot_info.parking_cnt > 0)
	{
		Data temp = max_wait_priority.heapPop();
		int temp_car_Idx = temp.Idx;

		if (car_info[temp_car_Idx].state != WAIT) continue;
		if (car_info[temp_car_Idx].parking_arrive_time != temp.priority) continue;

		car_info[temp_car_Idx].state = PARKING;
		car_info[temp_car_Idx].total_wait_time += current_time - car_info[temp_car_Idx].parking_arrive_time;
		car_info[temp_car_Idx].parking_arrive_time = current_time;
		parking_lot_info.wait_cnt--;
		parking_lot_info.parking_cnt++;
	}
	return cost;
}
```

### [solution-1] STL 완전탐색

```c

```

### [solution-2] STL 부분탐색

```c

```
