## 171125_서버접속

- [solution-1] 완전탐색 getUserID(): char* => string
- [solution-2] hash table: unordered_map 2665 ms (MAX_USER 탐색)
- [solution-3] hash table: array - unordered_map 936 ms
- [solution-4] hash table: vector - undorded_map 1206 ms
- [solution-5] vector - unordered_map 1387 ms
- [solution-6] vector - unordered_map => Tick() 개선 58 ms


### [solution-1] 완전탐색 1508 ms

```c
#include <string>

#define MAX_USER 50000

using namespace std;

struct User {
	string id;				// 입력값
	string password;		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};


User user[MAX_USER];
int userCount;


int getUserID(string id)
{
	for (int i = 0; i < userCount; i++) {
		if (user[i].id == id) {
			return i;
		}
	}
	return -1;
}

/////////////////////////////////////////////////////////////
void Init()
{
	userCount = 0;
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	user[userCount].id = string(id);
	user[userCount].password = string(password);
	user[userCount].defaulttime = defaulttime;

	user[userCount].loginTime = defaulttime;
	user[userCount].isLogout = false;

	userCount++;
}

void Logout(char id[11])
{
	int uIdx = getUserID(string(id));

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	user[uIdx].isLogout = true;
}

void Connect(char id[11], char password[11])
{
	int uIdx = getUserID(string(id));

	if (uIdx == -1)
		return;

	if (user[uIdx].isLogout)
		return;

	if (user[uIdx].password != string(password))
		return;

	user[uIdx].loginTime = user[uIdx].defaulttime;
}

int Tick()
{
	int logoutUserCnt = 0;

	for (int i = 0; i < userCount; i++) {
		if (user[i].isLogout)
			continue;

		user[i].loginTime -= 1;

		if (user[i].loginTime == 0) {
			user[i].isLogout = true;
			logoutUserCnt++;
		}
	}
	return logoutUserCnt;
}
```

### [solution-2] unordered_map 2665 ms

```c
#define MAX_USER 50000

#include <string>
#include <unordered_map>

using namespace std;

struct User {
	string password;		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};

//unordered_map<string, User> users;				// 초기 메모리 미할당	3729 ms
unordered_map<string, User> users(MAX_USER);		// 초기 메모리 할당		2665 ms
int userCnt;

/////////////////////////////////////////////////////////////
void Init()
{
	users.clear();
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	string userID = string(id);

	users[userID] = User();
	users[userID].password = string(password);
	users[userID].defaulttime = defaulttime;

	users[userID].loginTime = defaulttime;
	users[userID].isLogout = false;
}

void Logout(char id[11])
{
	string userID = string(id);

	if (not users[userID].isLogout)
		users[userID].isLogout = true;
}

void Connect(char id[11], char password[11])
{
	string userID = string(id);

	if (users[userID].isLogout)
		return;

	if (users[userID].password != string(password))
		return;

	users[userID].loginTime = users[userID].defaulttime;
}

int Tick()
{
	int logoutUserCnt = 0;
	size_t userCount = users.size();

	for (auto& u: users) {		// MAX_USER 검색 - 비효율
		if (u.second.isLogout)
			continue;

		u.second.loginTime -= 1;

		if (u.second.loginTime == 0) {
			u.second.isLogout = true;
			logoutUserCnt++;
		}
	}
	return logoutUserCnt;
}
```

### [solution-3] hash table: array - unordered_map 936 ms

```c
#define MAX_USER 50000

#include <string>
#include <unordered_map>
#include <array>
#include <vector>

using namespace std;

struct User {
	string password;		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};

unordered_map<string, int> mapID;
array<User, MAX_USER> users;
int userCnt;

/////////////////////////////////////////////////////////////
void Init()
{
	users.fill({});
	mapID.clear();
	userCnt = 0;
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	string strID = string(id);
	int userID = userCnt;

	mapID[strID] = userCnt;
	userCnt += 1;

	//users[userID] = User();
	users[userID].password = string(password);
	users[userID].defaulttime = defaulttime;

	users[userID].loginTime = defaulttime;
	users[userID].isLogout = false;
}

void Logout(char id[11])
{
	int userID = mapID[string(id)];

	if (not users[userID].isLogout)
		users[userID].isLogout = true;
}

void Connect(char id[11], char password[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogout)
		return;

	if (users[userID].password != string(password))
		return;

	users[userID].loginTime = users[userID].defaulttime;
}

int Tick()
{
	int logoutUserCnt = 0;

	for (int i = 0; i < userCnt; i++) {
		if (users[i].isLogout)
			continue;

		users[i].loginTime -= 1;

		if (users[i].loginTime == 0) {
			users[i].isLogout = true;
			logoutUserCnt++;
		}
	}
	return logoutUserCnt;
}
```

### [solution-4] hashtable: vector - undorded_map 1206 ms

```c
#define MAX_USER 50000		// 객체의 최대값

#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

struct User {
	string password;		// 입력값
	int defaulttime;		// 입력값

	bool isLogout;
	int loginTime;			// 로그인 상태를 유지할 수 있는 시간
};

unordered_map<string, int> mapID;
//array<User, MAX_USER> users;						// 936 ms
vector<User> users;									// 1191 ms (push_back) vs. 1196 ms (emplace_back)
//vector<User> users(MAX_USER);						// 1206 ms
int userCnt;

//unordered_map<string, User> users;				// 초기 메모리 미할당	3729 ms
//unordered_map<string, User> users(MAX_USER);		// 초기 메모리 할당		2665 ms

/////////////////////////////////////////////////////////////
void Init()
{
	//users.fill({});
	users.clear();
	mapID.clear();
	userCnt = 0;
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	string strID = string(id);
	int userID = userCnt;

	//users.push_back(User());
	users.emplace_back(User());
	mapID[strID] = userCnt;
	userCnt += 1;

	//users[userID] = User();
	users[userID].password = string(password);
	users[userID].defaulttime = defaulttime;

	users[userID].loginTime = defaulttime;
	users[userID].isLogout = false;
}

void Logout(char id[11])
{
	int userID = mapID[string(id)];

	if (not users[userID].isLogout)
		users[userID].isLogout = true;
}

void Connect(char id[11], char password[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogout)
		return;

	if (users[userID].password != string(password))
		return;

	users[userID].loginTime = users[userID].defaulttime;
}

int Tick()
{
	int logoutUserCnt = 0;

	for (int i = 0; i < userCnt; i++) {
	//for (int i = 0; i < users.size(); i++) {
		if (users[i].isLogout)
			continue;

		users[i].loginTime -= 1;

		if (users[i].loginTime == 0) {
			users[i].isLogout = true;
			logoutUserCnt++;
		}
	}

	return logoutUserCnt;
}
```

### [solution-5] Ref. Code: vector / unordered_map / current timestamp 1387 ms

```c
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

struct User {
	string password;		// 입력값
	int defaultTime;		// 입력값

	bool isLogin;
	int logoutTime;			// 로그아웃 되는 시간 = currentTime + defaultTime
};

unordered_map<string, int> mapID;
vector<User> users;
int currentTime;			// current timestamp

/////////////////////////////////////////////////////////////
void Init()
{
	mapID.clear();
	users.clear();
	currentTime = 0;
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	int userID = users.size();

	mapID[string(id)] = userID;

	users.push_back(User());
	users[userID].password = string(password);
	users[userID].defaultTime = defaulttime;
	users[userID].logoutTime = currentTime + users[userID].defaultTime;
	users[userID].isLogin = true;
}

void Logout(char id[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogin)
		users[userID].isLogin = false;
}

void Connect(char id[11], char password[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogin && users[userID].password == string(password)) {
		users[userID].logoutTime = currentTime + users[userID].defaultTime;
	}
}

int Tick()
{
	int logoutUserCnt = 0;
	currentTime += 1;

	// count_if 적용해 볼 것 (algorithm)
	for (auto& u: users) {
		if (u.isLogin && u.logoutTime == currentTime) {
			u.isLogin = false;
			logoutUserCnt++;
		}
	}

	//for (int i = 0; i < users.size(); i++) {
	//	if (users[i].isLogin && users[i].logoutTime == currentTime) {
	//		users[i].isLogin = false;
	//		logoutUserCnt++;
	//	}
	//}
	return logoutUserCnt;
}
```

### [solution-6] Tick() 개선: 50000 x 50000 = 25억번 수행 58 ms

```c
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

struct User {
	string password;		// 입력값
	int defaultTime;		// 입력값

	bool isLogin;
	int logoutTime;			// 로그아웃 되는 시간 = currentTime + defaultTime
};

unordered_map<string, int> mapID;
vector<User> users;
int currentTime;			// current timestamp

unordered_map<int, vector<int>> logoutUsers;

/////////////////////////////////////////////////////////////
void Init()
{
	mapID.clear();
	users.clear();
	currentTime = 0;

	logoutUsers.clear();
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	int userID = users.size();
	mapID[string(id)] = userID;

	users.push_back(User());
	users[userID].password = string(password);
	users[userID].defaultTime = defaulttime;
	users[userID].logoutTime = currentTime + users[userID].defaultTime;
	users[userID].isLogin = true;

	logoutUsers[users[userID].logoutTime].push_back(userID);
}

void Logout(char id[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogin)
		users[userID].isLogin = false;
}

void Connect(char id[11], char password[11])
{
	int userID = mapID[string(id)];

	if (users[userID].isLogin && users[userID].password == string(password)) {
		users[userID].logoutTime = currentTime + users[userID].defaultTime;
		logoutUsers[users[userID].logoutTime].push_back(userID);
	}
}

int Tick()
{
	int logoutUserCnt = 0;
	currentTime += 1;

	for (auto uID : logoutUsers[currentTime]) {
		if (users[uID].isLogin && users[uID].logoutTime == currentTime) {
			users[uID].isLogin = false;
			logoutUserCnt++;
		}
	}

	//for (auto& u : users) {
	//	if (u.isLogin && u.logoutTime == currentTime) {
	//		u.isLogin = false;
	//		logoutUserCnt++;
	//	}
	//}
	return logoutUserCnt;
}
```

### unordered_map / unordered_multimap 50 ms

```cpp
#include <string>
#include <unordered_map>

using namespace std;

#define LOGIN	1
#define LOGOUT	0

struct User {
	string password{};
	int defaultTime{};
	bool state{};
	int logoutTime{};
};

unordered_map<string, User> users;
unordered_multimap<int, string> logoutUsers;
int currentTime;

/////////////////////////////////////////////////////////////
void Init()
{
	users.clear();
	logoutUsers.clear();
	currentTime = 0;
}

void NewAccount(char id[11], char password[11], int defaulttime)
{
	users.emplace(string(id), User{ string(password), defaulttime, LOGIN, currentTime + defaulttime });
	logoutUsers.emplace(users[string(id)].logoutTime, string(id));
}

void Logout(char id[11])
{
	if (users[string(id)].state == LOGIN)
		users[string(id)].state = false;
}

void Connect(char id[11], char password[11])
{
	if (users[string(id)].state == LOGIN && users[string(id)].password == string(password)) {
		users[string(id)].logoutTime = currentTime + users[string(id)].defaultTime;
		logoutUsers.emplace(users[string(id)].logoutTime, string(id));
	}
}

int Tick()
{
	currentTime += 1;
	int logoutUserCnt = 0;
	auto range = logoutUsers.equal_range(currentTime);

	for (auto it = range.first; it != range.second; it++) {
		auto& uID = it->second;
		if (users[uID].state == LOGIN && users[uID].logoutTime == currentTime) {
			users[uID].state = LOGOUT;
			logoutUserCnt++;
		}
	}
	return logoutUserCnt;
}
```
